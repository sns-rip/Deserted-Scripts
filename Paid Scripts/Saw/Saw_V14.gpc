/* 
   SSSSSSSSSSSSSSS              AAA   WWWWWWWW                           WWWWWWWW                             1111111       444444444  
 SS:::::::::::::::S            A:::A  W::::::W                           W::::::W                            1::::::1      4::::::::4  
S:::::SSSSSS::::::S           A:::::A W::::::W                           W::::::W                           1:::::::1     4:::::::::4  
S:::::S     SSSSSSS          A:::::::AW::::::W                           W::::::W                           111:::::1    4::::44::::4  
S:::::S                     A:::::::::AW:::::W           WWWWW           W:::::W      vvvvvvv           vvvvvvv1::::1   4::::4 4::::4  
S:::::S                    A:::::A:::::AW:::::W         W:::::W         W:::::W        v:::::v         v:::::v 1::::1  4::::4  4::::4  
 S::::SSSS                A:::::A A:::::AW:::::W       W:::::::W       W:::::W          v:::::v       v:::::v  1::::1 4::::4   4::::4  
  SS::::::SSSSS          A:::::A   A:::::AW:::::W     W:::::::::W     W:::::W            v:::::v     v:::::v   1::::l4::::444444::::444
    SSS::::::::SS       A:::::A     A:::::AW:::::W   W:::::W:::::W   W:::::W              v:::::v   v:::::v    1::::l4::::::::::::::::4
       SSSSSS::::S     A:::::AAAAAAAAA:::::AW:::::W W:::::W W:::::W W:::::W                v:::::v v:::::v     1::::l4444444444:::::444
            S:::::S   A:::::::::::::::::::::AW:::::W:::::W   W:::::W:::::W                  v:::::v:::::v      1::::l          4::::4  
            S:::::S  A:::::AAAAAAAAAAAAA:::::AW:::::::::W     W:::::::::W                    v:::::::::v       1::::l          4::::4  
SSSSSSS     S:::::S A:::::A             A:::::AW:::::::W       W:::::::W                      v:::::::v     111::::::111       4::::4  
S::::::SSSSSS:::::SA:::::A               A:::::AW:::::W         W:::::W                        v:::::v      1::::::::::1     44::::::44
S:::::::::::::::SSA:::::A                 A:::::AW:::W           W:::W                          v:::v       1::::::::::1     4::::::::4
 SSSSSSSSSSSSSSS AAAAAAA                   AAAAAAAWWW             WWW                            vvv        111111111111     4444444444  
*/


/*                                ùêåùêîùêíùêì ùêëùêÑùêÄùêÉ
THIS SCRIPT IS FOR PUBLIC USE, IF SOMEONE HAS SOLD YOU THIS YOU HAVE BEEN SCAMMED!
			
DM me on discord if you have any questions or need help. Saw#1234 Here is my server link https://discord.gg/sawscripts

Make sure you are all set up good in ZEN studio, mainly for mouse and keyboard players.BUT WORKS WITH CONTROLLER 

First steps after putting this script into the Zen slot:
1. To access the main menu press L2/LT and menu/options
2. Adjust VM speed:
    For Mouse and Keyboard best is 8ms or default
    For controller 6ms or 4ms
    
3.  Match you deadzone to in game one ( 1 = 0.01 )VERY IMPORTANT I USE .10  WITH THESE VALUES
4.  Adjust Lazer Beam (Anti recoil)
5.  Adjust "SOFT AIM" if you think it is too weak or too shaky, strength and boost, you can go up or down, evil has a shake effect increase/decrease to your liking.
      (hip Boost increasing aa when hip firing) 
6.  Aim hax: left/right strafe
7.  target tracker ads left and right tracking. higher vales will jitter your screen. Death Tracker, keep the same 
11. Rat detector, keep the same if you new to zen, if not you can try to mess with these values. Diff shapes have diff effects.
12. Silent tracker, keep the same if you new to zen, if not you can try to mess with these values.
11. Headshot, headshot aa
11. hold breath, holds snipers breath
13. Trigger Bot(rapid fire) to use quick toggle the combo is hold L-DPAD and tap RT
11. Swap spam, fast yy combo (YY glitch is best for multiplayer, will not work properly in wz)
14. Aim glitch, ads your gun in and out very fast
13. Iron man, anti flinch when your getting shot
14. Sweet evil section, i suggest leaving this as is, unless you know what your doing.
15. Silent tracker, i suggest leaving this as is, unless you know what your doing.
  
   
    			VERY IMPORTANT FOR JITTER MOD TO WORK RIGHT
  1. Use default button layout and sticks
  2. Use toggle hold for equiptment
  3. Turn EVERYTHING off in the menu(i mean everything) besides jitter mod
  4. MUST use decoy grenade and throwing knife! DONT EVER THROW THESE HOLD ONTO THEM
  5. put vm speed to default
  
  Expedite shotgun and pistols work amazing. m16 can be a bit buggy

=============================================================================================================================
  Instructions - Please Read                                                                                            
=============================================================================================================================
        /*------------------------------- INSTRUCTIONS PLEASE READ ------------------------------------------
        =====================================================================================================
        Enter Mod Menu                        = hold ADS & press PS4_OPTIONS  
        -----------------------------------------------------------------------------------------------------
        Scroll between MODs  Go back          = PS4_UP 
        -----------------------------------------------------------------------------------------------------
        Scroll between MODs  Go forward       = PS4_DOWN 
        -----------------------------------------------------------------------------------------------------
        Scroll between Options Go back        = PS4_RIGHT 
        -----------------------------------------------------------------------------------------------------
        Scroll between Options Go forward     = PS4_LEFT 
        -----------------------------------------------------------------------------------------------------
        Exit Menu                             = PS4_CIRCLE 
        -----------------------------------------------------------------------------------------------------
        Enter Edit Menu To Change Values      = PS4_CROSS 
        -----------------------------------------------------------------------------------------------------
        Exit Edit Menu To Mod Menu            = PS4_CIRCLE
        -----------------------------------------------------------------------------------------------------
        Edit Menu - change values by 1        = hold ADS & press LEFT(decrease by 1)/RIGHT(increase by 1)
        -----------------------------------------------------------------------------------------------------
        Edit Menu - change values by 10       = hold ADS & press DOWN(decrease by 10)/UP(increase by 10)
        -----------------------------------------------------------------------------------------------------
        THANKS EVERYONE WHO HELPED WITH THIS, AND LET ME USE THEIR CODE PROPS TO YALL ALSO! 
        ====================================================================================================*/
        
//===============================================================
//    BUTTON LAYOUT                                              
//===============================================================
define BTN_FIRE             = PS4_R2;
define BTN_AIM              = PS4_L2;
define BTN_SPRINT           = PS4_L3;
define BTN_CROUCH           = PS4_CIRCLE;
define BTN_JUMP             = PS4_CROSS;
define BTN_SWAP             = PS4_TRIANGLE;
define BTN_RELOAD           = PS4_SQUARE;
define BTN_MELEE            = PS4_R3;
define BTN_TACTICAL         = PS4_L1;
define BTN_LETHAL           = PS4_R1;
define UP                   = PS4_UP;
define RIGHT                = PS4_RIGHT;
define DOWN                 = PS4_DOWN;
define LEFT                 = PS4_LEFT;
define aim_x                = PS4_RX;
define aim_y                = PS4_RY;
define strafe               = PS4_LX;
define walk                 = PS4_LY;
//===============================================================
//    ADJUSTABLE VARIABLES                                       
//===============================================================
// Index to find Value Name string - switchable in game with left/right in ModEdit
int adjust_variable_idx;                  
int AR_vertical;
int AR_horizontal;
int AimAssistTime;
int AimAssistSize;
int AimAssistOpSize;
int AimAssistOpTime;
int HIPBoost
int Rot_AA_Size;
int Rot_AA_Time;
int DeadZoneSize;
int TtSize;
int TtTime;
int RF_hold;
int RF_release;
int SlideDelay;                  
int HeadShotStrength;     
int HeadShotHoldTime;
int polar_aasist_radius;
int polar_aasist_steps;
int trackingSize;  
int trackingSpeed;  
int aimglitch1;
int aimglitch2;
int antidw_vertical;
int antidw_horizontal;
int SteadyAimResolution;
int TrackerStrength;
int TrackerSpeed;
int RADIUS;
int ACTIVE_TRACKING;
int FractioN;
int ANGLE;
int AIM_SMOOTHING_FACTOR;
int SitBitchStartTime;
int SitBitchTime;
///Led Lights
int CountLED;
int RED1;
int BLUE1;
int GREEN1;
int RED=1;
int GREEN=1;
int BLUE=1;

//---Adjustable Variables Count                          
define AMOUNT_OF_VALNAME_IDX = 34; 
//===============================================================
//    MODS TOGGLE VARIABLES                                      
//===============================================================
// Number of MODS -----------------------------------------------
define MAX_MODS_COUNT = 17;                          
// Index to find Mod Toggle Variable 
int modName_idx;  
//  MODS Toggles ------------------------------------------------
  int antirecoil_onoff; 
  int SOFTAIM;
  int ToggleStickyAim;
  int TargetTracker;
  int taylorTracking;
  int polar_aim_assist_onoff;
  int ToggleTracker;
  int ToggleSweetAssist;
  int HeadShotAssist_onoff; 
  int DeadZone;
  int holdbreath_onoff;
  int rapidfire_onoff;
  int ToggleCancelSlide;
  int aimabuse_onoff;
  int jitter_onoff;
  int antidw_on;
  int SitBitchOnOff;
  int VM_Speed;
//===============================================================
//    MODS TEXT TO DISPLAY                                       
//===============================================================
// Mod Name      -   Text to Display
  const string ANTIRECOIL           = "Lazer Beam" ;
  const string AIMASSISTOP			= "Soft Aim";
  const string STICKYAA       		= "Aim HAX" ; 
  const string TARGETTRACKER		= "Target Tracker";
  const string TD_TRACKING		    = "Death Rumble" ;
  const string POLARAIMASSIST_TD    = "Rat Detector" ;
  const string SILENTTRACKER	    = "Silent Tracker" ;
  const string SWEETASSIST 			= "Sweet Assist";
  const string HEADSHOT_ASSIST      = "HeadShot Hax" ; 
  const string DEADZONE				= "DeadZone";
  const string HOLDBREATH           = "Hold Breath" ;
  const string RAPIDFIRE            = "Trigger Bot" ;
  const string SLIDE_CANCEL_MW      = "Swap Spam" ;
  const string AIMABUSE		        = "Aim Glitch" ;
  const string JITTER		        = "Jitter" ;
  const string ANTIDW		        = "Iron Man" ;
  const string SITBITCH		        = "Dodge Shot" ;
  const string VMSPEED              = "VM Speed" ;
// Mod VALUES      -   Text to Display

//===============================================================
//    TITLE STRING                                               
//===============================================================
const string OFF   = "OFF";    
const string ON    = "ON";   
const string SCRIPT_ONOFF  = "Kill Mode";   
// Constant bytes - Convert numbers array - ASCII_NUM[column number] 
const int8 ASCII_NUM[] =                          
//      0  1  2  3  4  5  6  7  8  9  (column numbers)
      {48,49,50,51,52,53,54,55,56,57};  
 const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }
      // (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
                                                   
const string NO_EDIT_VAR1  = "Nothing to";//  17 
const string NO_EDIT_VAR2  = "change here";// 12       
const uint8 Options [] = {
  1 , // ANTIRECOIL # 1
  1 , // AA OP 2
  1 , // STICKYAA # 3
  1, // target tracker4
  1 ,//td track5
  30, // POLARAIMASSIST_TD # 6
  1, // silent tracker # 7
  1, // sweet
  1, // Head Shot Assist # 7
  1 , // DEADZONE8
  1 , // HOLDBREATH # 9
  9,  // RAPIDFIRE # 10
  1, // SLIDE_CANCEL_MW # 11
  1, // aim glitch # 12
  1, //jitter 13
  1, //antidw 14
  1, //sit 14
  50  // VMSPEED # 15
};
const uint8 EditVal [] = {
  1 , // ANTIRECOIL # 1
  1 , // AA OP2
  1 , // STICKYAA # 3
  1, // target tracker4
  1, //td track5
  1, // POLARAIMASSIST_TD # 6
  1, // silent tracker # 7
  1, //sweet
  1, // Head Shot Assist # 7
  1 , // DEADZONE8
  0 , // HOLDBREATH # 9
  1,  // RAPIDFIRE # 10
  1, // SLIDE_CANCEL_MW # 11
  1, // aim glitch # 12
  0, // jitter # 13
  1, //antidw 14
  1, //sit 14
  0  // VMSPEED # 15
};
const uint8 OptRange [][] = {
  { 0 , 1 }, // ANTIRECOIL # 1
  { 4 , 8 }, // AA OP2
  { 2 , 3 }, // STICKYAA # 3
  { 10 , 11 },  // target track4
  { 19 , 20 }, //td track5
  { 17 , 18 },  // POLARAIMASSIST_TD # 6
  { 25 , 27 }, // silent tracker # 7
  { 28 , 32 }, //sweet
  { 15 , 16 }, // Head Shot Assist # 7
  { 9 , 9 },  // DEADZONE8
  { 0 , 0 }, // HOLDBREATH # 9
  { 12 , 13 }, // RAPIDFIRE # 10
  { 14 , 14 },  // SLIDE_CANCEL_MW # 11
  { 21 , 22 },  // aim glitch # 12
  { 0 , 0 },  // jitter # 13
  { 23 , 24 },  // antidw # 14
  { 33 , 34 },  // sit # 14
  { 0 , 0 } // VMSPEED # 15
};
const uint8 Min_Max_Options [][]={ 
  { 0 , 1 }, // ANTIRECOIL # 1
  { 0 , 1 },  // AA OP2
  { 0 , 1 }, // STICKYAA # 3
  { 0 , 1 },  // target track4
  { 0 , 1 }, //td track5
  { 0 , 5 },  // POLARAIMASSIST_TD # 6
  { 0 , 1 }, // silent tracker # 7
  { 0 , 1 }, // sweet tracker # 7
  { 0 , 1 }, // Head Shot Assist # 7
  { 0 , 1 },   //DEADZONE8
  { 0 , 1 }, // HOLDBREATH # 9
  { 0 , 3 }, // RAPIDFIRE # 10
  { 0 , 1 },  // SLIDE_CANCEL_MW # 11
  { 0 , 1 },  // aim glitch # 12
  { 0 , 1 },  // jitter # 13
  { 0 , 1 },  // antidw # 14
  { 0 , 1 },  // sit # 14
  { 0 , 5 }  // VMSPEED # 15
}; 
       
const string EditVarStr []={ 
"AR Vertical", // 1
"AR Horizont", // 2
"HAX Time", // 3
"HAX Strength",// 4
"Soft Strength", // 5
"Soft Boost",  // 6
"Hip Boost", //7
"Evil Size", //8
"Evil Time", //9
"DZ Size", // 10
"Track Size", // 11
"Track Time", // 12
"RF Speed", // 13
"RF Release", // 14
"Swap Delay",  // 15
"HeadShot Strength", //16
"HeadShot Wait", //17
"Rat Radius", // 18
"Rat Steps",  // 19
"Death Size",	//20
"Death Speed",	//21
"Aim Glitch",	//22
"Aim Glitch ADS",//23
"Vertical",	//24
"Horizontal",//25
"Resolution",//26
"Strength",	//27
"Speed",//28
"Radius",
"Active Track",
"Fraction",
"Angle",
"Smoothing",
"Start Time",
"Time"
};
/////////////////////////////////////////////////////////////////////////////  
define TimeToShowIntroPicture = 30000;
/////////////////////////////////////////////////////////////////////////////  
///   INITIALIZATION BLOCK                                                      
/////////////////////////////////////////////////////////////////////////////   
init {  
antirecoil_onoff     = get_pvar(SPVAR_1,1,1,1); 
ToggleStickyAim 	= get_pvar(SPVAR_2,1,1,1);  
SOFTAIM 			= get_pvar(SPVAR_4,1,1,1);
DeadZone			= get_pvar(SPVAR_5,1,1,1);
TargetTracker		= get_pvar(SPVAR_16,1,1,1);
holdbreath_onoff  	= get_pvar(SPVAR_19,1,1,0);
rapidfire_onoff   	= get_pvar(SPVAR_20,1,3,0);
ToggleCancelSlide 	= get_pvar(SPVAR_23,1,1,0);
ToggleTracker 		= get_pvar(SPVAR_41,1,1,1);
ToggleSweetAssist	= get_pvar(SPVAR_45,1,1,1);
HeadShotAssist_onoff = get_pvar(SPVAR_25,1,1,0);
polar_aim_assist_onoff = get_pvar(SPVAR_28,1,5,2);
taylorTracking		 = get_pvar(SPVAR_31,1,1,1);
aimabuse_onoff		 = get_pvar(SPVAR_34,1,1,0);
jitter_onoff		 = get_pvar(SPVAR_37,1,1,0);
antidw_on   	 	= get_pvar(SPVAR_38, 1, 1, 0);
SitBitchOnOff   	= get_pvar(SPVAR_50, 1, 1, 0);
VM_Speed             = get_pvar(SPVAR_3,1,5,1);
AR_vertical       	= get_pvar(SPVAR_6, 1,99, 11);
AR_horizontal     	= get_pvar(SPVAR_7, 1,99, 0);
AimAssistTime    	= get_pvar(SPVAR_8, 1,20, 10);
AimAssistSize   	= get_pvar(SPVAR_9, 1,20, 6);
AimAssistOpTime		= get_pvar(SPVAR_10, 1,20, 18); // time
AimAssistOpSize		= get_pvar(SPVAR_11, 1,20, 12); // Strength
HIPBoost			= get_pvar(SPVAR_12, 1,100, 10); // Hip
Rot_AA_Size			= get_pvar(SPVAR_13, 1,100, 10); // rot size
Rot_AA_Time			= get_pvar(SPVAR_14, 1,100, 100); // rot time
DeadZoneSize		= get_pvar(SPVAR_15, 1,20, 5);
TtSize				= get_pvar(SPVAR_17, 1,20, 15);
TtTime				= get_pvar(SPVAR_18, 1,20, 10);
RF_hold       		= get_pvar(SPVAR_21, 1,1000, 30);
RF_release    		= get_pvar(SPVAR_22, 1,1000, 40);
SlideDelay     		= get_pvar(SPVAR_24,1,500, 80);
HeadShotHoldTime    = get_pvar(SPVAR_26,1,2000,500); 
HeadShotStrength    = get_pvar(SPVAR_27,1, 99,41);
polar_aasist_radius  = get_pvar(SPVAR_29, 1,30, 10);
polar_aasist_steps  = get_pvar(SPVAR_30,1,30, 18);
trackingSize		  = get_pvar(SPVAR_32, 1,100, 30);
trackingSpeed		  = get_pvar(SPVAR_33,1,100, 30);
aimglitch1			  = get_pvar(SPVAR_35,1,200, 100);
aimglitch2			  = get_pvar(SPVAR_36,1,100, 1);
antidw_vertical 	= get_pvar(SPVAR_39, 1, 100, 60);
antidw_horizontal 	= get_pvar(SPVAR_40, 1, 100, 30);
SteadyAimResolution = get_pvar(SPVAR_42, 1, 40, 2);
TrackerStrength		 = get_pvar(SPVAR_43, 1, 40, 12);
TrackerSpeed 		= get_pvar(SPVAR_44, 1, 40, 34);
RADIUS 				= get_pvar(SPVAR_46, 1, 40, 12);
ACTIVE_TRACKING		 = get_pvar(SPVAR_47, 1, 100, 6);
FractioN		 	= get_pvar(SPVAR_48, 10, 999, 10);
ANGLE				= get_pvar(SPVAR_53, 1, 999, 10);
AIM_SMOOTHING_FACTOR = get_pvar(SPVAR_49, 1, 100, 20);
SitBitchStartTime	= get_pvar(SPVAR_51, 10, 10, 1);
SitBitchTime		 = get_pvar(SPVAR_52, 1, 999, 100);
}// end of init block



const int8 ANGLEVAL[] = { -100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100};
const int8 POLAR_RADIUSVAL[] = { 100,-100,-99,-98,-97,-96,-95,-94,-93,-91,-90,-89,-88,-87,-86,-85,-84,-82,-81,-80,-79,-78,-77,-76,-75,-73,-72,-71,-70,-69,-68,-67,-66,-64,-63,-62,-61,-60,-59,-58,-57,-55,-54,-53,-52,-51,-50,-49,-48,-46,-45,-44,-43,-42,-41,-40,-39,-37,-36,-35,-34,-33,-32,-31,-30,-28,-27,-26,-25,-24,-23,-22,-21,-19,-18,-17,-16,-15,-14,-13,-12,-10,-9,-8,-7,-6,-5,-4,-3,-11,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,55,56,57,58,59,60,61,62,64,65,66,67,68,69,70,71,73,74,75,76,77,78,79,80,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98,100,100,100,99,98,97,96,95,94,93,91,90,89,88,87,86,85,84,82,81,80,79,78,77,76,75,73,72,71,70,69,68,67,66,64,63,62,61,60,59,58,57,55,54,53,52,51,50,49,48,46,45,44,43,42,41,40,39,37,36,35,34,33,32,31,30,28,27,26,25,24,23,22,21,19,18,17,16,15,14,13,12,10,9,8,7,6,5,4,3,1,-1,-1,-2,-3,-4,-5,-6,-7,-8,-10,-11,-12,-13,-14,-15,-16,-17,-19,-20,-21,-22,-23,-24,-25,-26,-28,-29,-30,-31,-32,-33,-34,-35,-37,-38,-39,-40,-41,-42,-43,-44,-46,-47,-48,-49,-50,-51,-52,-53,-55,-56,-57,-58,-59,-60,-61,-62,-64,-65,-66,-67,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-82,-83,-84,-85,-86,-87,-88,-89,-91,-92,-93,-94,-95,-96,-97,-98,-100};   
const int8 Polar_Array[]={100,100,100,100,100,100,100,100,99,99,99,99,98,98,97,97,97,96,95,95,94,94,93,92,92,91,90,89,89,88,87,86,85,84,83,82,81,80,79,78,77,75,74,73,72,71,70,69,67,66,65,63,62,61,59,58,56,55,53,52,50,49,47,46,44,43,41,40,38,36,35,33,31,30,28,26,25,23,21,20,18,16,14,13,11,9,7,6,4,2,0,-1,-3,-5,-7,-8,-10,-12,-13,-15,-17,-19,-20,-22,-24,-25,-27,-29,-30,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-48,-50,-51,-53,-54,-55,-57,-58,-60,-61,-62,-64,-65,-66,-68,-69,-70,-71,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-89,-90,-91,-92,-92,-93,-93,-94,-95,-95,-96,-96,-97,-97,-97,-98,-98,-99,-99,-99,-99,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-99,-99,-99,-98,-98,-98,-97,-97,-96,-96,-95,-94,-94,-93,-93,-92,-91,-90,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-72,-71,-70,-69,-67,-66,-65,-63,-62,-61,-59,-58,-56,-55,-53,-52,-50,-49,-47,-46,-44,-43,-41,-40,-38,-36,-35,-33,-31,-30,-28,-26,-25,-23,-21,-20,-18,-16,-14,-13,-11,-9,-7,-6,-4,-2,0,2,4,6,7,9,11,13,14,16,18,20,21,23,25,26,28,30,31,33,35,36,38,40,41,43,44,46,47,49,51,52,54,55,56,58,59,61,62,63,65,66,67,69,70,70,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,88,89,89,90,91,92,92,93,94,94,95,95,96,97,97,97,98,98,99,99,99,99,100,100,100,100,100,100,100};
const int16 pollarArr[] ={ 23170,  23167,  23156,  23139,  23114,  23082,  23044,  22998,  22945,  22885,  22818,  22745,  22664,  22577,  22482,  22381,  22273,  22158,  22036,  21908,  21773,  21632,  21483,  21329,  21167,  21000,  20825,  20645,  20458,  20265,  20066,  19861,  19650,  19432,  19209,  18980,  18745,  18505,  18259,  18007,  17750,  17487,  17219,  16946,  16667,  16384,  16096,  15802,  15504,  15201,  14894,  14582,  14265,  13944,  13619,  13290,  12957,  12620,  12278,  11934,  11585,  11233,  10878,  10519,  10157,  9792,  9424,  9053,  8680,  8304,  7925,  7544,  7160,  6774,  6387,  5997,  5605,  5212,  4817,  4421,  4024,  3625,  3225,  2824,  2422,  2019,  1616,  1213,  809,  404,  00,  -404,  -809,  -1213,  -1616,  -2019,  -2422,  -2824,  -3225,  -3625,  -4024,  -4421,  -4817,  -5212,  -5605,  -5997,  -6387,  -6774,  -7160,  -7544,  -7925,  -8304,  -8680,  -9053,  -9424,  -9792,  -10157,  -10519,  -10878,  -11233,  -11585,  -11934,  -12278,  -12620,  -12957,  -13290,  -13619,  -13944,  -14265,  -14582,  -14894,  -15201,  -15504,  -15802,  -16096,  -16384,  -16667,  -16946,  -17219,  -17487,  -17750,  -18007,  -18259,  -18505,  -18745,  -18980,  -19209,  -19432,  -19650,  -19861,  -20066,  -20265,  -20458,  -20645,  -20825,  -21000,  -21167,  -21329,  -21483,  -21632,  -21773,  -21908,  -22036,  -22158,  -22273,  -22381,  -22482,  -22577,  -22664,  -22745,  -22818,  -22885,  -22945,  -22998,  -23044,  -23082,  -23114,  -23139,  -23156,  -23167,  -23170,  -23167,  -23156,  -23139,  -23114,  -23082,  -23044,  -22998,  -22945,  -22885,  -22818,  -22745,  -22664,  -22577,  -22482,  -22381,  -22273,  -22158,  -22036,  -21908,  -21773,  -21632,  -21483,  -21329,  -21167,  -21000,  -20825,  -20645,  -20458,  -20265,  -20066,  -19861,  -19650,  -19432,  -19209,  -18980,  -18745,  -18505,  -18259,  -18007,  -17750,  -17487,  -17219,  -16946,  -16667,  -16384,  -16096,  -15802,  -15504,  -15201,  -14894,  -14582,  -14265,  -13944,  -13619,  -13290,  -12957,  -12620,  -12278,  -11934,  -11585,  -11233,  -10878,  -10519,  -10157,  -9792,  -9424,  -9053,  -8680,  -8304,  -7925,  -7544,  -7160,  -6774,  -6387,  -5997,  -5605,  -5212,  -4817,  -4421,  -4024,  -3625,  -3225,  -2824,  -2422,  -2019,  -1616,  -1213,  -809,  -404,  00,  404,  809,  1213,  1616,  2019,  2422,  2824,  3225,  3625,  4024,  4421,  4817,  5212,  5605,  5997,  6387,  6774,  7160,  7544,  7925,  8304,  8680,  9053,  9424,  9792,  10157,  10519,  10878,  11233,  11585,  11934,  12278,  12620,  12957,  13290,  13619,  13944,  14265,  14582,  14894,  15201,  15504,  15802,  16096,  16384,  16667,  16946,  17219,  17487,  17750,  18007,  18259,  18505,  18745,  18980,  19209,  19432,  19650,  19861,  20066,  20265,  20458,  20645,  20825,  21000,  21167,  21329,  21483,  21632,  21773,  21908,  22036,  22158,  22273,  22381,  22482,  22577,  22664,  22745,  22818,  22885,  22945,  22998,  23044,  23082,  23114,  23139,  23156,  23167,  23170 };
const int16 TrackerCords[] = {0, 8, 17,23, 34, 41, 52, 59,63,69, 75 ,81,87, 90, 104, 121, 139, 156,173, 190, 207, 224, 241, 258, 275, 292, 309, 325,342, 358, 374, 390, 406, 422, 438, 453, 469, 484,500, 515, 529, 544, 559, 573, 587, 601, 615, 629,642, 656, 669, 682, 694, 707, 719, 731, 743, 754,766, 777, 788, 798, 809, 819, 829, 838, 848, 857,866, 874, 882, 891, 898, 906, 913, 920, 927, 933, 939, 945, 951, 956, 961, 965, 970, 974, 978, 981,984, 987, 990, 992, 994, 996, 997, 998, 999, 999,1000 }

int angle,power,RIZ = -1,deltax,deltay,hyp,anglesx,anglesy,rnd, RAXIS,radius;
int RY,X;
int Sprint_Cancel,Speed =40,ANTIWOBBLE, BOOST;
int TrackerAngle = 270,CurrentRX,CurrentRY;
int ToggleSteadyAim = 1,ReT, CurRX, CurRY;
int x_aim_assist, y_aim_assist, input_mag, first_aim, rumble, toggle_active_tacking, active_tacking_counter, _angle, x_aim, y_aim, x_pred_position, x_velocity, kalman_kx, y_pred_position, y_velocity;
int kalman_y, kalman_py, kalman_ky, x_pred, xp_pred, y_pred, yp_pred, kalman_x, lx_strafe, ly_strafe, first_strafe, strafe_width, strafe_speed, toggle_active_strafing, active_strafing_counter, active_strafing;
int circle_x,circle_y,angle_,jitter_angleX,jitter_angleY;
int kalman_qx = 100, kalman_rx = 1000, kalman_px = 1000, kalman_qy = 100, kalman_ry = 1000;
int active_tacking = 1;
define fix16_maximum = 0x7FFFFFFF; /*!< the maximum value of fix16_t */
define fix16_minimum = 0x80000000; /*!< the minimum value of fix16_t */
define fix16_overflow = 0x80000000; /*!< the value used to indicate overflows when FIXMATH_NO_OVERFLOW is not specified */

define fix16_e = 178145; /*!< fix16_t value of e */
define fix16_one = 0x00010000; /*!< fix16_t value of 1 */
define fix16_1000 = 0x03E80000;
// (Display) Text formatting & alignment IDs
enum {
	alignCenter = -2, alignRight, alignLeft = 5,
	alignBottom = -1, alignTop = 5
}
const string sawscriptname[] = { "SAW v14" };
///////////////////////////////////////////////////////////////////////////// 
///   MAIN BLOCK                                                             
/////////////////////////////////////////////////////////////////////////////

init {
	active_tacking  = (((360 + ANGLE)/ANGLE) + 1) * ACTIVE_TRACKING;
	kalman_rx = fix16_from_float(0,FractioN);
	kalman_ry = kalman_rx;	
	kalman_qx = fix16_from_float(0,100);
	kalman_qy = kalman_qx;
	active_strafing = (((360 + trackingSpeed)/trackingSpeed) + 1) * 3;
	combo_run(cboGreeting); // Run greeting
}
main {//---------------------------------
	if(get_ival(BTN_AIM) > 1)
    set_val(BTN_AIM, 100);

    if(get_ival(BTN_FIRE) > 1)
    set_val(BTN_FIRE, 100);

    if(RED==255){RED1=FALSE;}if(GREEN==255){GREEN1=FALSE;}if(BLUE==255){BLUE1=FALSE;}if(RED==1){RED1=TRUE;}if(GREEN==1){GREEN1=TRUE;}if(BLUE==1){BLUE1=TRUE;}CountLED = random(1,300);
	if(((CountLED)>=1) && (CountLED)<=100){if(RED1==TRUE){RED+=1;set_rgb(RED,GREEN,BLUE);CountLED = random(1,300);}if(RED1==FALSE){RED-=1;set_rgb(RED,GREEN,BLUE);CountLED = random(1,300);}}
	if(((CountLED)>=101) && (CountLED)<=200){if(GREEN1==TRUE){GREEN+=1;set_rgb(RED,GREEN,BLUE);CountLED = random(1,300);}if(GREEN1==FALSE){GREEN-=1;set_rgb(RED,GREEN,BLUE);CountLED = random(1,300);}}
	if(((CountLED)>=201) && (CountLED)<=300){if(BLUE1==TRUE){BLUE+=1;set_rgb(RED,GREEN,BLUE);CountLED = random(1,300);}if(BLUE1==FALSE){BLUE-=1;set_rgb(RED,GREEN,BLUE);CountLED = random(1,300);}}
   /////////////////////////////////////////
 if(get_ival(BTN_AIM)){
     if(event_press(PS4_SHARE)){
         EntireScript_OnOff    = !EntireScript_OnOff;
         blinck(EntireScript_OnOff);
         cls_oled(0);
         //display_mod(f_idx, f_string, mod_name, f_toggle, f_option)
         display_mod( center_x(sizeof(SCRIPT_ONOFF)- 1, OLED_FONT_MEDIUM_WIDTH) ,SCRIPT_ONOFF [0],EntireScript_OnOff ,1);
         show_mesage_time = 2000;
 		 //--- Set Virtual Machine Speed to Default if script is OFF    
 		 if(!EntireScript_OnOff) set_Virtual_Machine_Speed(VM_Default); 
     }
 }
                          
 if(show_mesage_time){
     show_mesage_time -= get_rtime();
     if(show_mesage_time <= 0) {
         cls_oled(0);    
     }
 }
                               
//============================================================
// KILL SWITCH FOR ENTIRE SCRIPT
//============================================================
 if(EntireScript_OnOff){
  //--- Set Virtual Machine Speed to Default for MENU                     
	if(ModEdit || ModMenu) set_Virtual_Machine_Speed(VM_Default);
    if(display_EDIT){                
    	  // Clear OLED screen         
        cls_oled(0);                        
       // display_edit(f_idx, f_string, f_print, f_val) 
		if(EditVal[ modName_idx ] == 0 ){  
			  //--- print label                
		    line_oled(1,45,127,45,1,0);    
		    print( center_x( 17, OLED_FONT_SMALL_WIDTH ), 20, OLED_FONT_SMALL, 1, NO_EDIT_VAR1[0] ); 
		    print( center_x( 12, OLED_FONT_SMALL_WIDTH ), 33, OLED_FONT_SMALL, 1, NO_EDIT_VAR2[0] ); 
		}                                                                                            
		else {//----  ELSE BEGIN --------------  
          display_edit( adjust_variable_idx [adjust_variable_idx + 1]);
          adjust_variable_idx [adjust_variable_idx + 1] = edit_val(adjust_variable_idx [adjust_variable_idx + 1] );
		}//--- ELSE END   ----------- 
   }//  end of display edit  
    if(refresh_OLED)
    { 
        // Clear OLED screen 
        cls_oled(0);       
                           
        // Draw Rectangle 
         
        // Display Mod Name and togle status  : ON/OFF   
        if(modName_idx == 0)display_mod( center_x(sizeof(ANTIRECOIL)- 1, OLED_FONT_SMALL_WIDTH) ,ANTIRECOIL[0],antirecoil_onoff,Options[ modName_idx ]);
        if(modName_idx == 1)display_mod( center_x(sizeof(AIMASSISTOP)- 1, OLED_FONT_SMALL_WIDTH) ,AIMASSISTOP[0],SOFTAIM,Options[ modName_idx ]);
        if(modName_idx == 2)display_mod( center_x(sizeof(STICKYAA)- 1, OLED_FONT_SMALL_WIDTH) ,STICKYAA[0],ToggleStickyAim,Options[ modName_idx ]);
        if(modName_idx == 3)display_mod( center_x(sizeof(TARGETTRACKER)- 1, OLED_FONT_SMALL_WIDTH) ,TARGETTRACKER[0],TargetTracker,Options[ modName_idx ]);
        if(modName_idx == 4)display_mod( center_x(sizeof(TD_TRACKING)- 1, OLED_FONT_SMALL_WIDTH) ,TD_TRACKING[0],taylorTracking,Options[ modName_idx ]);
        if(modName_idx == 5)display_mod( center_x(sizeof(POLARAIMASSIST_TD)- 1, OLED_FONT_SMALL_WIDTH) ,POLARAIMASSIST_TD[0],polar_aim_assist_onoff,Options[ modName_idx ]);
        if(modName_idx == 6)display_mod( center_x(sizeof(SILENTTRACKER)- 1, OLED_FONT_SMALL_WIDTH) ,SILENTTRACKER[0],ToggleTracker,Options[ modName_idx ]);
        if(modName_idx == 7)display_mod( center_x(sizeof(SWEETASSIST)- 1, OLED_FONT_SMALL_WIDTH) ,SWEETASSIST[0],ToggleSweetAssist,Options[ modName_idx ]);
        if(modName_idx == 8)display_mod( center_x(sizeof(HEADSHOT_ASSIST)- 1, OLED_FONT_SMALL_WIDTH) ,HEADSHOT_ASSIST[0],HeadShotAssist_onoff,Options[ modName_idx ]);
        if(modName_idx == 9)display_mod( center_x(sizeof(DEADZONE)- 1, OLED_FONT_SMALL_WIDTH) ,DEADZONE[0],DeadZone,Options[ modName_idx ]);
        if(modName_idx == 10)display_mod( center_x(sizeof(HOLDBREATH)- 1, OLED_FONT_SMALL_WIDTH) ,HOLDBREATH[0],holdbreath_onoff,Options[ modName_idx ]);
        if(modName_idx == 11)display_mod( center_x(sizeof(RAPIDFIRE)- 1, OLED_FONT_SMALL_WIDTH) ,RAPIDFIRE[0],rapidfire_onoff,Options[ modName_idx ]);
        if(modName_idx == 12)display_mod( center_x(sizeof(SLIDE_CANCEL_MW)- 1, OLED_FONT_SMALL_WIDTH) ,SLIDE_CANCEL_MW[0],ToggleCancelSlide,Options[ modName_idx ]);
        if(modName_idx == 13)display_mod( center_x(sizeof(AIMABUSE)- 1, OLED_FONT_SMALL_WIDTH) ,AIMABUSE[0],aimabuse_onoff,Options[ modName_idx ]);
        if(modName_idx == 14)display_mod( center_x(sizeof(JITTER)- 1, OLED_FONT_SMALL_WIDTH) ,JITTER[0],jitter_onoff,Options[ modName_idx ]);
        if(modName_idx == 15)display_mod( center_x(sizeof(ANTIDW)- 1, OLED_FONT_SMALL_WIDTH) ,ANTIDW[0],antidw_on,Options[ modName_idx ]);
        if(modName_idx == 16)display_mod( center_x(sizeof(SITBITCH)- 1, OLED_FONT_SMALL_WIDTH) ,SITBITCH[0],SitBitchOnOff,Options[ modName_idx ]);
        if(modName_idx == 17)display_mod( center_x(sizeof(VMSPEED)- 1, OLED_FONT_SMALL_WIDTH) ,VMSPEED[0],VM_Speed,Options[ modName_idx ]);
         refresh_OLED = FALSE; 
    } 
    if(display_title){           
          // clear OLED screen    
    	    cls_oled(0);            
           // screen saver          
	         ModMenu = FALSE;   
           	display_title = FALSE;  
          	display_black = TRUE;                                   
    }                            
      
    //-----------------------------
    // Screen saver (OLED off)   
    if(display_black)         
    {                            
        count_black += get_rtime();
        if(count_black >= TimeToShowIntroPicture)   
        {                        
            cls_oled(0);         
            count_black = 0;      
            display_black = FALSE; 
        }                         
    }                           
                                
   /////////////////////////////////////////////////////////
   // MENU EDIT VALUES             
   if(ModEdit){ 
        block_all_inputs(); 
        if(MenuTimeOut){
            CheckIfBtnIsPressed();
        } 
       //--- Exit from EDIT MENU  
       if(event_release(PS4_CIRCLE)){
             ModEdit      = FALSE;           
             display_EDIT = FALSE;           
             ModMenu      = TRUE;            
             refresh_OLED = TRUE;   // display MODS 
       }                    
        ////////////////////////////////////////////////////////////////////////////////  
        //  GO FORWARD                                                                      
        if(!get_ival(BTN_AIM) && event_press(PS4_DOWN)){            
                                          
        	   adjust_variable_idx ++;                 
        	   if(adjust_variable_idx > OptRange[ modName_idx ][ 1 ])  adjust_variable_idx = OptRange[ modName_idx ][ 1 ]; 
             refresh_OLED = FALSE;      
             display_EDIT = TRUE;        
        }          
        ///////////////////////////////////////////////////////////////////////////////  
        //  GO BACK                                                                      
        if(!get_ival(BTN_AIM) && event_press(PS4_UP)){  
                                                               
        	   adjust_variable_idx --;                                      
        	   if(adjust_variable_idx < OptRange[ modName_idx ][ 0 ]) adjust_variable_idx = OptRange[ modName_idx ][ 0 ];
             refresh_OLED = FALSE;      
             display_EDIT = TRUE;        
        }                                                           
            /////////////////////////////////////////////////////// 
        if(MenuTimeOut){
            CheckIfBtnIsPressed();
        }
   }// end of EDIT MENU    
   /////////////////////////////////////////////////////////
   // EDIT MENU ON/OFF            
   if(get_ival(BTN_AIM) && event_press(PS4_OPTIONS)){  
        ModMenu = TRUE;  
        // toggle EditMenu ON/OFF                      
                 modName_idx  = 0;                   
                 refresh_OLED = TRUE;   // display Title    
                 display_EDIT = FALSE;        
                 MenuTimeOut  = menu_time_active;
   }      
   /////////////////////////////////////////////////////////
   // MENU SYSTEM              
   if(ModMenu){  
        block_all_inputs(); 
      //--- Exit from MENU  
      if(event_press(PS4_CIRCLE)){
          ModMenu = FALSE;                     
          ModEdit = FALSE;              
          combo_run(MESSAGE);             
      }                    
      //--- Enter in EDIT MENU 
      if(event_press(PS4_CROSS)){
          ModMenu             = FALSE;   
          adjust_variable_idx = OptRange[ modName_idx ][ 0 ]; 
          ModEdit             = TRUE;   
          display_EDIT        = TRUE; 
      }                    
                                  
        //Display MOD NAME and togle status 
        // Switch MODs                     
        if( !get_ival(BTN_AIM) && event_press(PS4_DOWN)){ 
                                          
        	   modName_idx ++;                 
        	   if(modName_idx > MAX_MODS_COUNT) modName_idx = 0; 
             //////////////////////////////////////
        	   blinck( modName_idx[modName_idx + 1]); 
             //////////////////////////////////////
        }                          
        if(!get_ival(BTN_AIM) && event_press(PS4_UP)){  
                                                               
        	  modName_idx --;                                      
        	  if(modName_idx < 0) modName_idx = MAX_MODS_COUNT;
             //////////////////////////////////////
        	   blinck( modName_idx[modName_idx + 1]); 
             //////////////////////////////////////
          }                        
        	//////////////////////////
                                  
                                  
        // screen saver           
        display_black = FALSE;    
        display_title = FALSE;    
        //////////////////////////////  
        // display mod name and Toggle ON/OFF | Scroll Options 
        if(!get_ival(BTN_AIM) ){    
             if(event_press(PS4_RIGHT)){ //   go back
                 modName_idx[modName_idx + 1] = f_go_back( modName_idx[modName_idx + 1] ); 
             }// go back 
             if(event_press(PS4_LEFT)){//   go forward
                 modName_idx[modName_idx + 1] = f_go_forward( modName_idx[modName_idx + 1] );
             }// go forward 
       } 
        refresh_OLED = TRUE;   
        set_val(PS4_RIGHT,0); 
        set_val(PS4_LEFT,0); 
        set_val(PS4_UP,0); 
        set_val(PS4_DOWN,0); 
        if(MenuTimeOut){
            CheckIfBtnIsPressed();
        }
    } 
    /////////////////////////////////////////////////////////////
    ///    END OF MENU  /////////////////////////////////////////
    /////////////////////////////////////////////////////////////
//========================================================================================================== 
   if(!ModEdit && !ModMenu){//  code for MODS
             //--- LED COLOR INDICATION        
         
             //---Virtual Machine Speed  
		    set_Virtual_Machine_Speed (VM_Speed);
			block_rumble();
			rnd = 359;
			set_polar(POLAR_LS, (DeadZoneSize * 10), (100 * rnd));
			set_polar(POLAR_RS, (DeadZoneSize * 10), (100 * rnd));
			
	
	//===========================================
    //   ANTI FLINCH 
    //===========================================
	if(antidw_on)
				{
					if((get_val(RUMBLE_A) || get_val(RUMBLE_B) || get_val(RUMBLE_LT) || get_val(RUMBLE_RT)) && !get_val(BTN_FIRE))
					{
						combo_run(anti_damage_wobble);
						
						if (get_val(BTN_LETHAL)){
						combo_stop(anti_damage_wobble);}
					}
				}
	
	//===========================================
    //   JITTER 
    //===========================================
	if (jitter_onoff){
	if(get_val(12)<-90 && event_press(8))
    Sprint_Cancel= TRUE; else if(get_val(12)>-88) Sprint_Cancel = FALSE;   
    if(Sprint_Cancel && event_press(4)) combo_run(Cancel);
    
    if(!Sprint_Cancel && get_val(4)) {
    set_val(4,0); combo_run(Jitter);}
}
	//===========================================
    //   AIM ABUSE 
    //===========================================
		if (aimabuse_onoff){
		if( get_ival(BTN_AIM) && get_ival(BTN_FIRE )){
		    		combo_run (AIM_ABUSE);}}
		    		
	//===========================================
    //   Death Track 
    //===========================================
			if(taylorTracking){
			if( get_ival(BTN_AIM) || get_ival(BTN_FIRE )) {
			Sweet_EviL_Strafe();
				}
				else{
		first_strafe 			= 0;}
		
		if( get_ival(BTN_AIM) || get_ival(BTN_FIRE ))
		{
    	jitter_angleX = (get_val(PS4_RX) - (trackingSize / 3)) ;
    	jitter_angleY = (get_val(PS4_RY) - (trackingSize / 3));
		angle_ = (angle_ + trackingSpeed) % 360;
        circle_x = (trackingSize / 3) * get_r_x_from_angle(angle_);
        circle_y = (trackingSize / 3) * get_r_y_from_angle(angle_);
		set_val(PS4_RX, circle_x + jitter_angleX);
        set_val(PS4_RY, circle_y + jitter_angleY);
    }
		}
	//===========================================
    //   DoNotAtMe Polar Aim Assist with Taylordrift21 shapes 
    //===========================================
              if(polar_aim_assist_onoff){
                               
                  actual_X = get_ival(aim_x);   
                  actual_Y = get_ival(aim_y); 
                  
                  actual_Magnitude = isqrt(pow(actual_X, 2) + pow(actual_Y, 2));  
                  max_Magnitude = (actual_Magnitude < 100);                      
                                                                        
                  if(!(time++ % STEP_INTERVAL)){                                  
                   angle += polar_aasist_steps;                                                 
                  }                                                               
                  angle = angle % 360;                                            
                  cos_angle_tdrift = Polar_Array[angle % 360];                           
                  sin_angle_tdrift = Polar_Array[(angle + 270) % 360]; 
                                  
                  if( get_ival(BTN_AIM) || get_ival(BTN_FIRE ) || get_ival(BTN_AIM) && get_ival(BTN_FIRE)){ 
                  
                      if(actual_Magnitude <= polar_aasist_radius){                                                      
                          sin_angle_tdrift -= actual_Y;                                                              
                          cos_angle_tdrift -= actual_X;                                                                 
                      }else {                                                                                       
                          sin_angle_tdrift = (sin_angle_tdrift * (200 - ((abs(actual_Y) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude; 
                          cos_angle_tdrift = (cos_angle_tdrift * (200 - ((abs(actual_X) + actual_Magnitude) / 10) * 10) / 200) * max_Magnitude; 
                      }                                                  
                      GetShapes(polar_aasist_radius); 
                     
                  } 
              } 

			//======================================================
            //   HEAD SHOT ASSIST
            //======================================================
			if(HeadShotAssist_onoff ) {
				RY = HeadShotStrength * -1;
				if(get_ival(BTN_FIRE) && get_ptime(BTN_FIRE) < HeadShotHoldTime) { 	
					offset(aim_y,RY);	
				}
			}
		    //===========================================
		    //   ANTI RECOIL 
		    //===========================================
     if(antirecoil_onoff && KS_anti_recoil){                               
    	    if( get_ival(BTN_AIM) && get_ival(BTN_FIRE )) {      
    	        combo_run(AntiRecoil);                 
    	    }                                          
                                                           
    	    if( abs(get_ival(aim_y)) > AR_Release || abs(get_ival(aim_x)) > AR_Release) { 
    	        combo_stop (AntiRecoil);               
    	    }                                
             
            if(get_ival(PS4_R3)){
                if(event_press(PS4_UP)){
                    AR_vertical += 1;
                }
                if(event_press(PS4_DOWN)) {
                    AR_vertical -= 1;
                }
                set_val(PS4_UP,0); set_val(PS4_DOWN,0);
                                                       
                if(event_press(PS4_LEFT)){
                    AR_horizontal -= 1;
                }
                if(event_press(PS4_RIGHT)) {
                    AR_horizontal +=  1;
                }
                set_val(PS4_LEFT,0); set_val(PS4_RIGHT,0);
                                                                
               //=============================================== 
               //               SAVE ANTI RECOIL                    
               //=============================================== 
               if(event_press(PS4_PS)){
                    combo_run(MESSAGE);       
               }
               set_val(PS4_PS,0);
           }
                                                  
     }// end of Anti Recoil    
            //--- CLEAR OLED SCREEN after message                                       
            if(time_to_clear_screen){               
                time_to_clear_screen -= get_rtime();
                if(time_to_clear_screen <= 0 ){     
                    QT_MESSAGE_TIMEOUT();     
                }                              
            }            
                          
            //===========================================
            //   Sticky Aim 
            //===========================================
            if(ToggleStickyAim){
                if( get_ival(BTN_AIM) && get_ival(BTN_FIRE )){
                    combo_run(StickyAim);
                    combo_run(aa_booster_combo);
                    }
			}
	//===========================================
    //   SOFT AIM 
    //===========================================
            if(SOFTAIM){
            	
				combo_run(SAW_movement_finder)
				SAWMOVEMENTX()
				SOFTaim(PS4_RY,(0));
				
                if( get_ival(BTN_AIM) || get_ival(BTN_FIRE ) || get_ival(BTN_AIM) && get_ival(BTN_FIRE)){
                    	combo_run(SAWMOVE);
                    	combo_run(SAW1);
						combo_run(SAW2);
						combo_run(SAW3);
						combo_run(SAW5);
						combo_run(SAW666);
						SAW1();
						SAW2();
						SAW3();
						SAW5();
		}
		if (get_ival(BTN_FIRE)){
                    combo_run(HipBoost);
                    if( get_ival(BTN_AIM) || get_ival(BTN_AIM) && get_ival(BTN_FIRE))
                    combo_stop(HipBoost);
            }}

	//===========================================
    //   TARGET TRACK 
    //===========================================
            if(TargetTracker) {
            if( get_ival(BTN_AIM) || get_ival(BTN_FIRE ) || get_ival(BTN_AIM) && get_ival(BTN_FIRE))
				{ power = POLAR_RS;
				{ if(power >= 0 && power <= 100 )  
				power = power; 
				else power = random(0,100);}radius = POLAR_RADIUS;
				{ if(radius >= -32768 && radius <= 32767 ) radius = radius;
				else radius = random(-32768,32767);}angle = POLAR_ANGLE;
				{if(angle >= 0 && angle <= 359 )angle = angle;
				else angle = random(0, 359);}
				block_rumble();
				CalcAngle()
				SawPolarAim();
				combo_run(SawPolarAim)RAXIS = get_polar(POLAR_RS, POLAR_ANGLE);
				combo_run (AA1);
				combo_run (AA2);
				combo_run (AA3);
				combo_run (AA4);
				combo_run (SawAim);
				combo_run (SawAim2);
				combo_run(POLARTRACKER);}
 
			}
			//===========================================
		    //   Steady Tracking
		    //===========================================

					if(ToggleTracker)
					{
					if(get_ival(BTN_AIM) || get_ival(BTN_FIRE) || get_ival(BTN_AIM) && get_ival(BTN_FIRE))
						{
					CurRX = get_ival(PS4_RX);
					CurRY = get_ival(PS4_RY);
					

						if(get_ival(BTN_AIM) || get_ival(BTN_FIRE) || get_ival(BTN_AIM) && get_ival(BTN_FIRE))
						{
							CurRX += get_polar_coordinate(TrackerStrength, sin_(TrackerAngle));
							CurRY += get_polar_coordinate(TrackerStrength, cos_(TrackerAngle));
						}
						else
						{
							CurRX += get_polar_coordinate(TrackerStrength, cos_(TrackerAngle));
							CurRY += get_polar_coordinate(TrackerStrength, sin_(TrackerAngle));	
						}
							TrackerAngle = ((TrackerAngle + TrackerSpeed) % 360);
							set_val(PS4_RX, clamp(CurRX, -100, 100));
							set_val(PS4_RY, clamp(CurRY, -100, 100));
						
					}}

				if(ToggleSteadyAim)
		{
		if( get_ival(BTN_AIM) || get_ival(BTN_FIRE ) || get_ival(BTN_AIM) && get_ival(BTN_FIRE)){	
			CurrentRX = get_val(aim_x);
			CurrentRY = get_val(aim_y);

			CurrentRX = GetSteadyAim(CurrentRX, SteadyAimResolution);
			CurrentRY = GetSteadyAim(CurrentRY, SteadyAimResolution);

			set_val(aim_x, clamp(CurrentRX, -100, 100));
			set_val(aim_y, clamp(CurrentRY, -100, 100));
		}}
		//===========================================
        //   HOLD BREATH 
        //===========================================
		   if(holdbreath_onoff){
				if(get_val(BTN_AIM))
		    		set_val(BTN_SPRINT, 100);
	                      
	   			if(get_val(BTN_AIM) && get_lval(BTN_SPRINT)) 
	       			set_val(BTN_SPRINT, 0);  
	        }
   
         //===========================================
        //   RAPID FIRE ON/OFF
        //===========================================
        if(rapidfire_onoff) { 
            if(get_ival(PS4_LEFT) && event_press(BTN_FIRE)){
                 KS_RapidFire = !KS_RapidFire;          
                 set_rumble_tipe(rapidfire_onoff); 
                 display_MOD_status(KS_RapidFire,sizeof(RAPIDFIRE)- 1,RAPIDFIRE[0]);
                 set_val(BTN_FIRE,0);
            }               
        }
        if(rapidfire_onoff && KS_RapidFire ) { 
            /////////////////////////////////////////
            if ((rapidfire_onoff == 2 && get_ival(BTN_AIM) && get_ival(BTN_FIRE)) || (rapidfire_onoff == 1 && get_ival(BTN_FIRE) && !get_ival(BTN_AIM)) || (rapidfire_onoff == 3 && get_ival(BTN_FIRE))) {
                 combo_run(RAPID_FIRE_cmb);         
            }                                       
        }
	//===========================================
    //   SWAP SPAM 
    //===========================================
                   if(ToggleCancelSlide){
            				if(get_ptime(BTN_SWAP) >= 100){
					if(event_release(BTN_SWAP))
						combo_run(CancelSlideMW)
				}
			}
			
	//===========================================
    //   Evil
    //===========================================
			if(ToggleSweetAssist){
			if(get_ival(BTN_AIM) || get_ival(BTN_FIRE ) || get_ival(BTN_AIM) && get_ival(BTN_FIRE)) {
		Sweet_EviL_Aim_Assist(x_aim, y_aim);
		
		x_aim = get_ival(aim_x);
		y_aim = get_ival(aim_y);
	
		
		set_val(aim_x, clamp(x_aim_assist, -100, 100));
		set_val(aim_y, clamp(y_aim_assist, -100, 100));
		
		// Run the prediction
		Sweet_EviL_Movement_Predict(x_aim, y_aim, 1);
		x_aim = Sweet_EviL_Aim_Smoothing(x_pred_position, x_aim);
		y_aim = Sweet_EviL_Aim_Smoothing(y_pred_position, y_aim);
		}
		} 
		
	//===========================================
    //   Sit Bitch
    //===========================================
    
    if(SitBitchOnOff){
		if(	get_val(BTN_FIRE) && get_ptime(BTN_FIRE) <= 200 && !get_val(BTN_AIM)){
				combo_run(sitBitch);
				}
				if(combo_running(sitBitch) && (event_release(BTN_AIM) || !get_val(BTN_FIRE) || event_press(BTN_TACTICAL) || event_press(BTN_LETHAL) || event_press(BTN_MELEE))){
			combo_stop(sitBitch)
			}
		}
            } //  end of MODS CODE 
    } //  ENTIRE SCRIPT KILL SWITCH 
} //  end of main block 
///////////////////////////////////////////////////////////////////////////// 
///   COMBO BLOCK                                                             
/////////////////////////////////////////////////////////////////////////////
const int16 ValRange [][] ={
{ -99,99 }, // AR_vertical
{ -99,99 }, // AR_horizontal
{ 1,40 }, // AimAssistTime
{ 1,40 }, // AimAssistSize
{ 1,40 }, // AIMASSISTOPsize
{ 1,40 }, // AIMASSISTOPtime
{ 0,100 }, // Hip
{ 0,100 }, // Rot. Size
{ 1,100 }, // Rot. Time
{ 0,40 }, //DeadZone
{ 0,40 }, //ttsize
{ 1,40 }, //tttime
{ 1,1000 }, // RF_hold
{ 1,1000 }, // RF_release
{ 1,500 }, // Slide cancel
{ 1,99 },  //HeadShotStrenght
{ 1,2000 }, //HeadShotHoldTime
{ 1,60 }, // polar_aasist_radius
{ 1,60 },  // polar_aasist_steps
{ 1,100 },	//td track
{ 1,100 },	//td track
{ 1,200 },	//aim glitch1
{ 1,200 },	//aim glitch2
{ 1,100 },	//antidw vert
{ 1,100 },	//antidw hor
{ 1,40 },	//RESOLUTION
{ 1,40 },	//SILENT SPEED
{ 1,40 },	//SILENT TIME
{ 1,40 },	//radius
{ 0,100 },	//tracking
{ 10,999 },	//fraction
{ 1,999 },	//angle
{ 0,100 },	//smoothing
{ 1,10 },	//sit
{ 1,999 }	//sit
};       
       
//-- VM Speed
define VM_Default = 0;
function set_Virtual_Machine_Speed (f_speed){
    if     (f_speed == 0) vm_tctrl(-0);//10 ms Default
    else if(f_speed == 1) vm_tctrl(-2);// 8 ms
    else if(f_speed == 2) vm_tctrl(-4);// 6 ms
    else if(f_speed == 3) vm_tctrl(-6);// 4 ms
    else if(f_speed == 4) vm_tctrl(-8);// 2 ms
    else if(f_speed == 5) vm_tctrl(-9);// 1 ms
}
           
int time_to_clear_screen;
function QT_MESSAGE_TIMEOUT (){     
	// Clear OLED Screen              
	cls_oled(0); // will clear oled   
	display_title  = FALSE;           
}                                  
                      
int exit_wait = 1500;
combo EXIT {     
	wait(exit_wait);     
	cls_oled(0);    
	ModMenu = FALSE;  
	ModEdit = FALSE;    
	display_EDIT = FALSE; 
	display_title = FALSE; 
}                      

define ColorOFF  = 0;
define Blue      = 1;
define Red       = 2;
define Green     = 3;
define Pink      = 4;
define SkyBlue   = 5;
define Yellow    = 6;
define White     = 7;
                      
data(                 
  0,0,0, //0. ColorOFF
  2,0,0, //1. Blue     
  0,2,0, //2. Red      
  0,0,2, //3. Green    
  2,2,0, //4. Pink     
  2,0,2, //5. SkyBlue 
  0,2,2, //6. Yellow   
  2,2,2  //7. White    
); // end of data segment-------------- 
// COLOR LED function        
//-------------------------------------------------------------- 
                                       
int data_indx;
function colourled(color) {  
    for( data_indx = 0; data_indx < 3; data_indx++ ) {
        set_led(data_indx,duint8 ((color * 3) + data_indx));
    }
}

// Refresh OLED              
    int display_title = TRUE;
    int display_black;      
    int refresh_OLED;        
    int ModMenu;    
    int ModEdit;   
    int display_EDIT;   
    int EntireScript_OnOff = TRUE;// Kill Swith For Entire Script   
    int show_mesage_time; 
////////////////////////////////////// 
/////////////////////////////////////// 
int count_black;                                       
int BlinckColor = 3;
int rumble_tipe = RUMBLE_A;
int LED_OnOff;

combo vibrate {                                   
	set_rumble(rumble_tipe, 100);                   
	wait(300);                                       
	reset_rumble();                                 
	wait(100);                                       
	set_rumble(rumble_tipe, 100);                   
	wait(300);                                       
	reset_rumble();                                 
}
combo LED_BLINK {                                 
	colourled(LED_OnOff);                           
	wait(200);                                      
	colourled(ColorOFF);                            
	wait(100);                                      
	colourled(LED_OnOff);                           
	wait(200);                                      
	colourled(ColorOFF);                             
	wait(100);                                      
}
 
combo StickyAim {
	offset_sticky_aa(PS4_LX,AimAssistSize * 10);
	wait(AimAssistTime  * 10);
    offset_sticky_aa(PS4_LX,inv(AimAssistSize * 10));
    wait(AimAssistTime  * 10);
    }
    combo aa_booster_combo{
 	X = random(inv(AimAssistSize), AimAssistSize);
 	offset(PS4_LX, 27);
	offset(PS4_LY, X);
	wait(AimAssistTime * 10);
	offset(PS4_LX, inv(25));
	offset(PS4_LY, X);
	wait(AimAssistTime * 8);
	offset(PS4_LY, X);
	offset(PS4_LX, 25);
	wait(AimAssistTime * 10);
	offset(PS4_LX, inv(27));
	offset(PS4_LY, X);
	wait(AimAssistTime * 8);
}
    
combo HipBoost {
SOFTaim(PS4_RX,AimAssistOpSize + HIPBoost)wait(AimAssistOpTime)
SOFTaim(PS4_RX,-AimAssistOpSize - HIPBoost)wait(AimAssistOpTime)
SOFTaim(PS4_RY,AimAssistOpSize + HIPBoost + 1)wait(AimAssistOpTime)
SOFTaim(PS4_RY,-AimAssistOpSize - HIPBoost - 1)wait(AimAssistOpTime)
SOFTaim(PS4_RY,AimAssistOpSize + HIPBoost + 1)wait(AimAssistOpTime)
SOFTaim(PS4_RX,-AimAssistOpSize - HIPBoost)wait(AimAssistOpTime)
SOFTaim(PS4_RX,AimAssistOpSize + HIPBoost)wait(AimAssistOpTime)
SOFTaim(PS4_RY,-AimAssistOpSize - HIPBoost - 1)wait(AimAssistOpTime)
}


/////////////////////////////////////////////

//===============================================================
//   MODS COMBO SECTION
//===============================================================
define ACTIVE_WHEN_ADS    = TRUE;                     
define ACTIVE_WHEN_FIRING = TRUE;  
define STEP_INTERVAL =  1; 
int KS_RapidFire = TRUE;
int SAWAIM_MOVEMENT_TRACK;
int D = 0;

combo sitBitch {
	wait(SitBitchStartTime * 250);
	set_val(BTN_CROUCH,100);
	wait(SitBitchTime);
	set_val(BTN_CROUCH,0);
	wait(SitBitchTime);
	set_val(BTN_JUMP,100);
	wait(SitBitchTime / 2);
	set_val(BTN_JUMP,100);
	set_val(BTN_JUMP,0);
	}

combo Jitter {
    set_val(20,100);
    set_val(4,100);
    wait(11);
    set_val(6,100);
    wait(11);
    set_val(17,100);
    wait(Speed);}
    
    combo Cancel {
    set_val(12,0);
    set_val(4,0);
    wait(11);
    Sprint_Cancel = FALSE;}
    
     combo AIM_ABUSE {
 	wait(aimglitch1);
    set_val(BTN_AIM, 0);
    wait(aimglitch2 - get_rtime());
    set_val(BTN_AIM, 0);}
    
    combo anti_damage_wobble {
	BOOST++;
	ANTIWOBBLE = get_val(aim_y) + antidw_vertical + BOOST;
	if(BOOST == 10) {
	BOOST = 0; }
	if(ANTIWOBBLE > 100) {
	ANTIWOBBLE = 100; }
	set_val(aim_y, ANTIWOBBLE * -1);
	ANTIWOBBLE = get_val(aim_x) + antidw_horizontal;
	if(ANTIWOBBLE > 100){
	ANTIWOBBLE = 100; }
	set_val(aim_x, ANTIWOBBLE);
}

combo RAPID_FIRE_cmb { 
  set_val(BTN_FIRE, 100);
  wait(RF_hold);
  set_val(BTN_FIRE,   0);
  wait(RF_release); 
  }
   
combo CancelSlideMW {              
	set_val(BTN_SWAP,100);
	wait(SlideDelay);
	set_val(BTN_SWAP,0);
	wait(SlideDelay);
	set_val(BTN_SWAP,100);
	wait(SlideDelay);
	set_val(BTN_SWAP,0);
	wait(SlideDelay);
	set_val(BTN_SWAP,100);
	wait(SlideDelay);
	set_val(BTN_SWAP,0);
	wait(SlideDelay);
	set_val(BTN_SWAP,100);
	wait(SlideDelay);
	set_val(BTN_SWAP,0);
	wait(SlideDelay);
	}

combo AA1 { 
Offset (aim_y, ((DeadZoneSize - 4) - 2)); wait(TtTime);
Offset (aim_y, ((-DeadZoneSize + 4) + 2));wait(TtTime);
} 

combo AA2 { 
Offset (aim_x, ( (DeadZoneSize - 4) / 2)); wait(TtTime); 
Offset (aim_x, ((-DeadZoneSize + 4) / 2)); wait(TtTime);
} 

combo AA3 { 
set_val (aim_y, get_ival (aim_y)); wait(TtTime);
set_val (aim_y, get_ival (aim_y)); wait(TtTime);
}
combo AA4 { 
set_val (aim_x, get_ival (aim_x)); wait(TtTime); 
set_val (aim_x, get_ival (aim_x)); wait(TtTime);
}
combo SawAim {
Offset(PS4_RY,1)
Offset(PS4_RX,-1)wait(TtTime)
Offset(PS4_RY,-1)
Offset(PS4_RX,1)wait(TtTime)
Offset(PS4_RY,2)
Offset(PS4_RX,1)wait(TtTime)
Offset(PS4_RY,-2)
Offset(PS4_RX,1)wait(TtTime)
Offset(PS4_RY,2)
Offset(PS4_RX,-2)wait(TtTime)
Offset(PS4_RY,-2)
Offset(PS4_RX,2)wait(TtTime)
}

combo SawAim2 {
Offset(PS4_RY,0)wait(TtTime)
Offset(PS4_RY,TtSize)wait(TtTime)
Offset(PS4_RY,0)wait(TtTime)
Offset(PS4_RY,-TtSize)wait(TtTime)
Offset(PS4_RY,1)wait(TtTime)
Offset(PS4_RY,TtSize)wait(TtTime)
Offset(PS4_RY,-1)wait(TtTime)
Offset(PS4_RY,-TtSize)wait(TtTime)
		}

combo SawPolarAim {
DK(aim_x,RIZ)wait(TtTime)
DK(aim_x,-RIZ - 1)wait(TtTime)
DK(aim_y,RIZ)wait(TtTime)
DK(aim_y,-RIZ)wait(TtTime)
DK(aim_y,RIZ)wait(TtTime)
DK(aim_x,-RIZ - 1)wait(TtTime)
DK(aim_x,RIZ )wait(TtTime)
DK(aim_y,-RIZ)wait(TtTime)
}

combo SAW1 {
set_val(PS4_RX,AimAssistOpSize + 1)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize - 1)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize - 1)wait(AimAssistOpTime)
set_val(PS4_RX,AimAssistOpSize )wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
}

combo SAW2 {
set_val(PS4_RX,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
}

combo SAW3 {
set_val(PS4_RX,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize + 1)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize - 1)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize + 1)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
}

combo SAW5 {
set_val(PS4_RX,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,-AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RX,AimAssistOpSize)wait(AimAssistOpTime)
set_val(PS4_RY,-AimAssistOpSize)wait(AimAssistOpTime)
}

combo SAWMOVE {
SAWMOVE(PS4_LX,Rot_AA_Size)
SAWMOVE(PS4_LY,-Rot_AA_Size)
wait(Rot_AA_Time)
SAWMOVE(PS4_LX,-Rot_AA_Size)
SAWMOVE(PS4_LY,Rot_AA_Size)
wait(Rot_AA_Time)
SAWMOVE(PS4_LX,Rot_AA_Size)
SAWMOVE(PS4_LY,Rot_AA_Size)
wait(Rot_AA_Time)
SAWMOVE(PS4_LX,-Rot_AA_Size)
SAWMOVE(PS4_LY,-Rot_AA_Size)
wait(Rot_AA_Time)
}
combo SAW666 {
SAWMOVE(PS4_LX,AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LX,-AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LY,AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LY,-AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LY,AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LX,-AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LX,AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
SAWMOVE(PS4_LY,-AimAssistOpSize / 2)wait(AimAssistOpTime / 2)
}

combo POLARTRACKER {	    	  	
		set_val(POLAR_RX,xy_val(POLAR_RX, AimAssistOpSize)); wait(AimAssistOpTime); 
		set_val(POLAR_RX,xy_val(POLAR_RX, AimAssistOpSize * -1));  wait(AimAssistOpTime);
		set_val(POLAR_RY,xy_val(POLAR_RY, AimAssistOpSize))wait(AimAssistOpTime);
		set_val(POLAR_RY,xy_val(POLAR_RY, AimAssistOpSize * -1)); wait(AimAssistOpTime);
		set_val(POLAR_RY,xy_val(POLAR_RY, AimAssistOpSize))wait(AimAssistOpTime);
		set_val(POLAR_RX,xy_val(POLAR_RX, AimAssistOpSize * -1));  wait(AimAssistOpTime);
		set_val(POLAR_RX,xy_val(POLAR_RX, AimAssistOpSize)); wait(AimAssistOpTime);
		set_val(POLAR_RY,xy_val(POLAR_RY, AimAssistOpSize * -1)); wait(AimAssistOpTime);
		}
		
combo SAW_movement_finder {
SAWAIM_MOVEMENT_TRACK = 1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
SAWAIM_MOVEMENT_TRACK = 1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
SAWAIM_MOVEMENT_TRACK = -1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
SAWAIM_MOVEMENT_TRACK = -1
if(get_val(PS4_RX) > 15 ||get_val(PS4_RY) < -15)
SAWAIM_MOVEMENT_TRACK = (-SAWAIM_MOVEMENT_TRACK + SAWAIM_MOVEMENT_TRACK)
}
combo cboGreeting {
	call(cboClearScreen);
	executeGreeting();
	wait(2000);
	call(cboGreetingText);
}
combo cboGreetingText {
	printText(alignCenter, alignCenter, sawscriptname[0], OLED_FONT_MEDIUM, OLED_WHITE);
	set_rumble(RUMBLE_A, 50);
	wait(720);
	set_rumble(RUMBLE_A, 50);
	set_rumble(RUMBLE_B, 100);
	wait(720);
	reset_rumble();
	wait(1440);
	
}
combo cboClearScreen {
	cls_oled(OLED_BLACK);
}

function set_rumble_tipe ( val) {                  
	if( val){ rumble_tipe = RUMBLE_A ; LED_OnOff = Green;}  
	else    { rumble_tipe = RUMBLE_B ; LED_OnOff = Red  ;} 
	combo_run(vibrate);                     
	combo_run(LED_BLINK);                   
}
function display_MOD_status(f_val,f_size,f_label){  
    if(!ModMenu && !ModEdit){                                           
        // Clear OLED Screen                          
        cls_oled(0); // will clear oled   
        print(f_size, 3, OLED_FONT_MEDIUM ,OLED_WHITE, f_label);   
        if( f_val ){
            print(center_x(sizeof(ON)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE, ON[0]);//MOD is ON
        }
        else{
            print(center_x(sizeof(OFF)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE, OFF[0]);// MOD is OFF
        }    
        time_to_clear_screen = 1500; 
    } 
}
// Prints text to the screen
 function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(dint8(s)); // Insert character into display buffer
    	s++; // Move to next character of the string
    } while(dint8(s)) // Check if a next character exists
}
int displayBuffer;
function flushBuffer(x, y, size, color) {
	// Decrement display buffer value for proper arithmetic
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4; // Additional 4 for padding from border
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
		// No alignLeft case is needed because alignLeft is set to the proper left alignment already
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4; // Additional 4 for padding from border
			break;	
		}
		// No alignTop case is needed because alignTop is set to the proper top alignment already
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

function Offset (Axis,Value) { set_val(Axis, clamp(Value * (100 - abs(get_val(Axis))) / 100 + get_val(Axis), -100, 100)); return; }

function SawPolarAim () {DK(aim_x,RIZ)} 

function DK( axis, offset_val) 
{set_val(axis, clamp(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));return;}

function atan(i)
{if (anglesx != anglesx){anglesx = 0;}
if (anglesy != anglesy){anglesy = 0;}
if (anglesx > 89){anglesx = 89;}
if (anglesx < -89){anglesx = -89;}
if (anglesy > 180){anglesy -= 360;}
if (anglesy < -180){anglesy += 180;}
return i;
return anglesx;
return anglesy;
return rad2deg(atan(lookAt * tan(deg2rad(POLAR_ANGLE / 2))) * POLAR_ANGLE)
return rad2deg(atan(((delta << 1 )/ POLAR_ANGLE)* tan(deg2rad(POLAR_ANGLE / 2))))
return tan(deg2rad(POLAR_ANGLE / 2)* tan(deg2rad(delta)))  }

int delta;
define fov = POLAR_RADIUS;
int radianval;

function tan(tanValue){radianval = atan(1) * (POLAR_ANGLE / 180);tanValue = atan (1);
return ANGLEVAL[(radianval/tanValue)];
return POLAR_RADIUSVAL[(radianval/tanValue)];
return 0;}

function deg2rad(degrees) 
{return POLAR_ANGLE * (( 4 ) / 180)return degrees;}

function rad2deg(radians) 
{return POLAR_RADIUS * (180 / (4*atan(1)))
return radians;}

int lookAt;

function CalcAngle()
{deltax = aim_x;deltay = aim_y;hyp = isqrt(deltax * deltax + deltay * deltay);
anglesx = rad2deg(sin(deltax / hyp));
anglesy = deg2rad(tan(deltay * deltay));
if(RAXIS < 45) {anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  POLAR_ANGLE;anglesy = ( deltay * sin(135 + deltax / hyp)) * 57 +  POLAR_ANGLE; } 
else if(RAXIS <  89) { anglesx = ( deltax/2 * tan(deltax / hyp)) * 57 +  POLAR_ANGLE;anglesy = ( deltay   * sin(deltay / hyp)) * 57 +  POLAR_ANGLE;}
else if(RAXIS < 135) { anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  POLAR_ANGLE; anglesy = ( deltay * sin(225 + deltax / hyp)) * 57 +  POLAR_ANGLE; }  
else if(RAXIS < 180) {anglesx = ( deltax * tan(deltax / hyp))  * 57 +  POLAR_ANGLE;anglesy = ( deltay/2 * sin(deltay / hyp)) * 57 +  POLAR_ANGLE; }
else if(RAXIS < 225) { anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  POLAR_ANGLE;  anglesy = ( deltay * sin(135 + deltax / hyp)) * 57 +  POLAR_ANGLE; }  
else if(RAXIS < 270) { anglesx = ( deltax/2 * tan(deltax / hyp)) * 57 +  POLAR_ANGLE;anglesy = ( deltay * sin(deltay / hyp))* 57 +  POLAR_ANGLE; }
else if(RAXIS < 315) { anglesx = ( deltax * tan(180 + deltax / hyp)) * 57 +  POLAR_ANGLE; anglesy = ( deltay * sin(225 + deltax / hyp)) * 57 +  POLAR_ANGLE; }
else { anglesx = ( deltax *   tan(deltax / hyp)) * 57 +  POLAR_ANGLE;anglesy = ( deltay/2 * sin(deltay / hyp)) * 57 +  POLAR_ANGLE; }}


function offset_sticky_aa(Stick,Value) {
  set_val(Stick, clamp(Value * (100 - abs(get_ival(Stick))) / 100 + get_ival(Stick), -100, 100));
  return;
}

function SOFTaim( axis,  offset_val) {
  set_val(axis, clamp(offset_val * (100 - abs(get_val(axis))) / 100 + get_val(axis), -100, 100));
  return;
} 


//////////////////////////////////////////////////////////////////////////// 
		
function SAW1() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > 15 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -15)
combo_stop(SAW1)return;}

function SAW2() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > 16 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -16)
combo_stop(SAW2)return;}

function SAW3() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > 17 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -17)
combo_stop(SAW3)return;}

function SAW5() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > 19 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -19)
combo_stop(SAW5)return;}

function SAWMOVEMENTX() {
if(abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) > 20 || abs(get_val(PS4_RX)) + abs(get_val(PS4_RY)) < -20)
combo_stop(SAW_movement_finder)return;} 

function SAWMOVE(Stick, Value) {
  if (Stick >= POLAR_LX) {
    set_val(Stick, clamp(Value * (32767 - abs(get_val(Stick))) / 32767 + get_val(Stick), -32767, 32767));
	return;}
      set_val(Stick, clamp(Value * (100 - abs(get_val(Stick))) / 100 + get_val(Stick), -100, 100));
}

function xy_val(f_axis,f_val) {	
	if(abs(get_val(f_axis)) < DeadZoneSize)	
		return f_val; 
		return get_val(f_axis); 
}

int Position,SpiralPosition1,SpiralPosition2,InnerSpiral,OuterSpiral; 
int MinRadius = 1;  // Leave Alone , This can be left alone and not need adjusted. \\
int time;                                             
int  cos_angle_tdrift, sin_angle_tdrift;                      
int actual_X, actual_Y, actual_Magnitude, max_Magnitude; 
function GetShapes(f_var) {     
   
    if(!SpiralPosition1)                                
    {
        InnerSpiral -= 1;
        if(InnerSpiral < MinRadius)
            SpiralPosition1 = TRUE;
    }
    else
    {
        InnerSpiral += 1;
        if(InnerSpiral > f_var)
            SpiralPosition1 = FALSE;
    }
    if(!SpiralPosition2)
    {
        OuterSpiral -= 1;
        if(OuterSpiral < MinRadius)
            SpiralPosition2 = TRUE;
    }
    else
    {
        OuterSpiral += 1;
        if(OuterSpiral >  f_var)
            SpiralPosition2 = FALSE;
    } 
    if( polar_aim_assist_onoff == 1)                    
    { 
        sin_angle_tdrift = (sin_angle_tdrift * f_var) /100;
        cos_angle_tdrift = (cos_angle_tdrift * f_var) /100;  
    } 
    if( polar_aim_assist_onoff == 2)        
    { 
        sin_angle_tdrift = (sin_angle_tdrift * f_var)/100;
        cos_angle_tdrift = (cos_angle_tdrift * f_var/2)/100; 
    }
    if( polar_aim_assist_onoff == 3)                     
    { 
        cos_angle_tdrift = (cos_angle_tdrift * f_var) /100;  
        sin_angle_tdrift = (sin_angle_tdrift * f_var/2)/100;  
    } 
    if( polar_aim_assist_onoff == 4)                  
    {
        sin_angle_tdrift = (sin_angle_tdrift * InnerSpiral) /100;
        cos_angle_tdrift = (cos_angle_tdrift * OuterSpiral) /100;  
    }
    if( polar_aim_assist_onoff == 5)
    {
        if(Position == 0 || Position == 1)
        {  
            actual_X = (get_ival(aim_x)) + ((cos_angle_tdrift * f_var))/100;
        }
        if(Position == 2 || Position == 3)
        {  
            actual_Y = (get_ival(aim_y)) + ((sin_angle_tdrift * f_var))/100;
        }
            Position++;        
            
        if(Position == 4)
        {
            Position = 0;
        }    
    }
    if(polar_aim_assist_onoff == 5 )
    {
           set_val(aim_x, actual_X);
           set_val(aim_y, actual_Y); 
    } 
    else
    {
        set_val(aim_x, calculate(actual_X + cos_angle_tdrift, -100, 100));
        set_val(aim_y, calculate(actual_Y + sin_angle_tdrift, -100, 100)); 
          
    }   
 }
function calculate(int v, int lo, int hi) { 
  if(v < lo) return lo;               
  if(v > hi) return hi;        
  return v;     
}  
int _ret;
int val;
function correctAngle(angle){
  if (angle < 0) angle = 360 + (angle % 360);
  angle = (angle + 90) % 360;
  return angle;
}
function sin(angle){
delta = isqrt(deltax * deltax + deltay * deltay);
lookAt = delta * 2 / POLAR_ANGLE
   angle = atan(1);
   val = delta / 180;
   return   ANGLEVAL[(angle * val)];
   return   POLAR_RADIUSVAL[(angle * val)];
   return 0;
  return lerp_16(pollarArr[(correctAngle(angle - 1))], pollarArr[(correctAngle(angle + 1))], 0x8000);
  }
  
function lerp_16(a, b, t) { return fix_to_int(lerp(int_to_fix(a), int_to_fix(b), t)); }
function int_to_fix(a) { return a * 0x10000; }
function fix_to_int(a) { if (a >= 0) return (a + 0x10000 >> 1) / 0x10000; return (a - 0x10000 >> 1) / 0x10000; }
function fix_mul(v1, v2) { return ((v1 >> 8) * (v2 >> 8)); }
function lerp(a, b, f) { return fix_mul((0x10000 - f), a) + fix_mul(f, b); }
function offset(Stick, Value) {
  if (Stick >= POLAR_RX) {
    set_val(Stick, clamp(Value * (32767 - abs(get_val(Stick))) / 32767 + get_val(Stick), -32767, 32767));
    return;
  }
  set_val(Stick, clamp(Value * (100 - abs(get_val(Stick))) / 100 + get_val(Stick), -100, 100));
}
function get_polar_coordinate(Radius, coef){

if((Radius > 20) )
	{
		Radius = 20;
	}
	else if((Radius > 32))
	{
		Radius = 32;
	}
	
	return((Radius * coef) / 1000);		
}
function GetSteadyAim(Axis, _Resolution) {
	if (Axis >= 0)
	{
		ReT = (Axis % _Resolution);

		if (ReT >= (_Resolution / 2))
			Axis = Axis + (_Resolution - ReT);
		else
			Axis -= ReT;
	}
	else
	{
		ReT = (Axis % _Resolution);

		if (abs(ReT) >= (_Resolution / 2))
			Axis = Axis - (_Resolution + ReT);
		else
			Axis += abs(ReT);
	}
		return Axis;
}
function get_r_x_from_angle(a) {
    return fix((a * 251) >> 15);
}
function get_r_y_from_angle(a) {
    return fix((a * 251) >> 15);
}
function fix(v) {
    if(v < -32767) {
        v = -32767;
    }
    if(v > 32767) {
        v = 32767;
    }
    return v;
}

////swwweeeettt
function Sweet_EviL_Aim_Assist(int _x, int _y)
{
	x_aim_assist = _x;
	y_aim_assist = _y;
		
	input_mag = isqrt((x_aim_assist * x_aim_assist) + (y_aim_assist * y_aim_assist));
	
		// calculate the current angle of joystick
	if (input_mag < DeadZoneSize)
	{
		x_aim_assist = 0;
		y_aim_assist = 0;
	}
	
	if(first_aim == 0)
	{
		first_aim = 1;
		angle = atan2_16bits(y_aim_assist, x_aim_assist);
	}
	else
	{
		angle += ANGLE;
		angle = (angle % 360);
	}
		
	rumble = 0;
		
	radius = RADIUS + rumble;
	
	
	
	if(toggle_active_tacking)
	{
		x_aim_assist = x_aim_assist + ((radius * sin_(angle)) / 1000);
		y_aim_assist = y_aim_assist + ((radius * cos_(angle)) / 1000);
	}
	else
	{
		x_aim_assist = x_aim_assist + ((radius * cos_(angle)) / 1000);
		y_aim_assist = y_aim_assist + ((radius * sin_(angle)) / 1000);
	}
	
	active_tacking_counter++;
	
	if(active_tacking == active_tacking_counter)
	{
		active_tacking_counter = 0;
		toggle_active_tacking = toggle_active_tacking ^^ 1;
	}
	
	x_aim_assist = clamp(x_aim_assist, -100, 100);
	y_aim_assist = clamp(y_aim_assist, -100, 100);	
}
function atan2_16bits( _y, _x)
{
// determine _angle
	if (_y >= 0)
	{ // oct 0,1,2,3
		if (_x >= 0)
		{ // oct 0,1
			if (_x > _y)
			{
				_angle = ((_y * 300) / _x);
			}
			else
			{
				if (_y == 0)
					_angle = 0; // (_x=0,_y=0)
				else
					_angle = 540 - ((_x * 300) / _y);

			}
		}
		else
		{ // oct 2,3
		  // if (inv(_x) <= _y) {
			if (_x >= inv(_y))
			{
				_angle = 540 - ((_x * 300) / _y);
			}
			else
			{
				_angle = 1080 + ((_y * 300) / _x);
			}
		}
	}
	else
	{ // oct 4,5,6,7
		if (_x < 0)
		{ // oct 4,5
		  // if (inv(_x) > inv(_y)) {
			if (_x < _y)
			{
				_angle = ((_y * 300) / _x) - 1080;
			}
			else
			{
				_angle = ((inv(_x) * 300) / _y) - 540;
			}
		}
		else
		{ // oct 6,7
		  // if (_x <= inv(_y)) {
			if (inv(_x) >= _y)
			{
				_angle = ((inv(_x) * 300) / _y) - 540;
			}
			else
			{
				_angle = ((_y * 300) / _x);
			}
		}
	}

	return (_angle / 6);
}

 function sin_( _angle)
{
	if (_angle <= 90)
	{
		_ret = (TrackerCords[_angle]);
	}
	else if (_angle <= 180)
	{
		_ret = (TrackerCords[180 - _angle]);
	}
	else if (_angle <= 270)
	{
		_ret = inv(TrackerCords[_angle - 180]);
	}
	else
	{
		_ret = inv(TrackerCords[360 - _angle]);
	}

	return _ret;
}

//################################################################################################# 

function cos_( _angle)
{
	if (_angle <= 90)
	{
		_ret = (TrackerCords[90 - _angle]);
	}
	else if (_angle <= 180)
	{
		_ret = inv(TrackerCords[_angle - 90]);
	}
	else if (_angle <= 270)
	{
		_ret = inv(TrackerCords[270 - _angle]);
	}
	else
	{
		_ret = (TrackerCords[_angle - 270]);
	}

	return _ret;
}

// Update the state of the system based on the measured position and elapsed time
function Sweet_EviL_Movement_Predict(int x_position, int y_position, int dt)
{
	// Compute the predicted state and error covariance
	x_pred = x_pred_position + (x_velocity * dt / 1000);
	xp_pred = kalman_px + kalman_qx;

	// Compute the Kalman gain
	kalman_kx = (xp_pred * 1000) / (xp_pred + kalman_rx);

	// Update the estimated state and error covariance
	kalman_x = x_pred + (kalman_kx * (x_position - x_pred) / 1000);
	kalman_px = (1000 - kalman_kx) * xp_pred / 1000;

	// Update the state of the system
	x_pred_position = clamp(kalman_x, -100, 100);
	
	x_velocity = x_velocity + (kalman_kx * (x_position - x_pred) / dt);

	// Compute the predicted state and error covariance
	y_pred = y_pred_position + (y_velocity * dt / 1000);
	yp_pred = kalman_py + kalman_qy;

	// Compute the Kalman gain
	kalman_ky = (yp_pred * 1000) / (yp_pred + kalman_ry);

	// Update the estimated state and error covariance
	kalman_y = y_pred + (kalman_ky * (y_position - y_pred) / 1000);
	kalman_py = (1000 - kalman_ky) * yp_pred / 1000;

	// Update the state of the system
	y_pred_position = clamp(kalman_y, -100, 100);
	y_velocity = y_velocity + (kalman_ky * (y_position - y_pred) / dt);
}

function Sweet_EviL_Aim_Smoothing(int pred, int prev)
{
	// Apply weight penderation to combine predicted and measured position
	return (((AIM_SMOOTHING_FACTOR  * prev) + (100 - AIM_SMOOTHING_FACTOR) * pred )/100);	
}

int fix_result_float;
int fix_float_sign;
function fix16_from_float(int integer_part, int fractional_part)
{
     if(integer_part < 0)
     	fix_float_sign = -1;
     else
     	fix_float_sign = 1;
     
     fix_result_float = fix16_from_int(abs(integer_part))
        + fix16_sdiv(fix16_from_int(clamp(fractional_part, 0, 1000)), fix16_1000);
    return fix_result_float * fix_float_sign;
}

function fix16_from_int(int a)
{
  return clamp(a, -32768, 32767) * fix16_one;
}
int result_sdiv;
function fix16_sdiv(int inArg0, int inArg1)
{
  result_sdiv = fix16_div(inArg0, inArg1);

  if (result_sdiv == fix16_overflow)
  {
    if ((inArg0 >= 0) == (inArg1 >= 0))
      return fix16_maximum;
    else
      return fix16_minimum;
  }

  return result_sdiv;
}
int remainder_div;
int divider_div;
int quotient_div;
int bit_div;
int result_div;

function fix16_div(int a, int b)
{
  // This uses the basic binary restoring division algorithm.
  // It appears to be faster to do the whole division manually than
  // trying to compose a 64-bit divide out of 32-bit divisions on
  // platforms without hardware divide.

  if (b == 0)
    return fix16_minimum;

  if(a >= 0)
  {
  	remainder_div = a;
  }
  else
  {
  	remainder_div = -a;
  }
  
  if(b >= 0)
  {
  	divider_div = b;
  }
  else
  {
  	divider_div = -b;
  }

  quotient_div = 0;
  bit_div = 0x10000;

  /* The algorithm requires D >= R */
  while (divider_div < remainder_div)
  {
    divider_div = divider_div<<1;
    bit_div = bit_div<<1;
  }

  if (!bit_div)
    return fix16_overflow;

  if (divider_div & 0x80000000)
  {
    // Perform one step manually to avoid overflows later.
    // We know that divider_div's bottom bit_div is 0 here.
    if (remainder_div >= divider_div)
    {
      quotient_div = quotient_div | bit_div;
      remainder_div = remainder_div - divider_div;
    }
    divider_div = divider_div>>1;
    bit_div = bit_div>>1;
  }

  /* Main division loop */
  while (bit_div && remainder_div)
  {
    if (remainder_div >= divider_div)
    {
      quotient_div = quotient_div | bit_div;
      remainder_div = remainder_div - divider_div;
    }

    remainder_div = remainder_div<<1;
    bit_div = bit_div>>1;
  }

  result_div = quotient_div;

  /* Figure out the sign of result_div */
  if ((a ^ b) & 0x80000000)
  {

    if (result_div == fix16_minimum)
      return fix16_overflow;

    result_div = -result_div;
  }

  return result_div;
}
function Sweet_EviL_Strafe()
{
	lx_strafe = get_ival(strafe);
	ly_strafe = get_ival(walk);
		
	input_mag = isqrt((lx_strafe * lx_strafe) + (ly_strafe * ly_strafe));
	
	// calculate the current STRAFE_SPEED of jolystick
	if (input_mag < DeadZoneSize)
	{
		lx_strafe = 0;
		ly_strafe = 0;
	}
	
	if(first_strafe)
	{
		first_strafe = 1;
		strafe_speed = atan2_16bits(ly_strafe, lx_strafe);
	}
	else
	{
		strafe_speed += trackingSpeed;
		strafe_speed = (strafe_speed % 360);
	}
		
	rumble = 0;
	
	
	strafe_width = trackingSize + rumble;
	
	if(strafe_width > 32)
	{
		strafe_width = 32;
	}
	else if(strafe_width < inv(31))
	{
		strafe_width = inv(31);
	}
	
	if(toggle_active_strafing)
	{
		lx_strafe = lx_strafe + ((strafe_width * cos_(strafe_speed)) / 1000);
		ly_strafe = ly_strafe + ((strafe_width * sin_(strafe_speed)) / 1000);
	}
	else
	{
		lx_strafe = lx_strafe + ((strafe_width * sin_(strafe_speed)) / 1000);
		ly_strafe = ly_strafe + ((strafe_width * cos_(strafe_speed)) / 1000);
	}
	
	active_strafing_counter++;
	
	if(active_strafing == active_strafing_counter)
	{
		active_strafing_counter = 0;
		toggle_active_strafing  = toggle_active_strafing ^^ 1;
	}
	
	lx_strafe = clamp(lx_strafe, -100, 100);
	ly_strafe = clamp(ly_strafe, -100, 100);	
	
	set_val(strafe, lx_strafe);
	set_val(walk, ly_strafe);
}

//-------------------------------------------------------------------------------------------
define AR_Release = 27;	  // change this value to set when antirecoil stops working (min: antirecoil value + 10) 
int KS_anti_recoil = TRUE;  
//------------------------------------------------------------------------------------------- 
   
//---------------------------------//          
combo AntiRecoil {  
D = get_ival(PS4_RY) +  AR_vertical;
 if(D>  100 + 100 - 100 )AR_vertical = 100 - 100 + 100;

set_val(PS4_RY,D)   
}           
 

      
define FONT_STATS_INDEX_WIDTH    = 0; 
define FONT_STATS_INDEX_HEIGHT   = 1; 
define FONT_STATS_INDEX_MAXCHARS = 2; 
                                      
                                      
//////////////////////////////////////////////////////////////// 
function horizontal_center_offset(number_characters, font_size) { 
    return (128 - number_characters * FONT_STATS[font_size][FONT_STATS_INDEX_WIDTH]) / 2;
}             
              
const string EXIT_TXT1 = "READY TO";  
const string EXIT_TXT2 = "SLAY"; 
                                     
////////////////////////////////////////////////////////////////////////////// 
///  SAVE  
function save_toggles () {  
                    
     set_pvar(SPVAR_1,antirecoil_onoff); 
     set_pvar(SPVAR_2,ToggleStickyAim);      
     set_pvar(SPVAR_4,SOFTAIM); 
     set_pvar(SPVAR_5,DeadZone); 
     set_pvar(SPVAR_16,TargetTracker);
     set_pvar(SPVAR_19,holdbreath_onoff);
     set_pvar(SPVAR_20,rapidfire_onoff);
     set_pvar(SPVAR_23,ToggleCancelSlide);
     set_pvar(SPVAR_41,ToggleTracker);
     set_pvar(SPVAR_45,ToggleSweetAssist);
     set_pvar(SPVAR_25,HeadShotAssist_onoff);
     set_pvar(SPVAR_28,polar_aim_assist_onoff);
     set_pvar(SPVAR_31,taylorTracking);
     set_pvar(SPVAR_34,aimabuse_onoff);
     set_pvar(SPVAR_37,jitter_onoff);
     set_pvar(SPVAR_38,antidw_on);
     set_pvar(SPVAR_50,SitBitchOnOff);
     set_pvar(SPVAR_3,VM_Speed);
     set_pvar(SPVAR_6,AR_vertical); 
     set_pvar(SPVAR_7,AR_horizontal); 
     set_pvar(SPVAR_8,AimAssistTime); 
     set_pvar(SPVAR_9,AimAssistSize);
     set_pvar(SPVAR_10,AimAssistOpTime);
     set_pvar(SPVAR_11,AimAssistOpSize);
     set_pvar(SPVAR_12,HIPBoost);
     set_pvar(SPVAR_13,Rot_AA_Size);		
     set_pvar(SPVAR_14,Rot_AA_Time);		
     set_pvar(SPVAR_15,DeadZoneSize);
     set_pvar(SPVAR_17,TtSize);
     set_pvar(SPVAR_18,TtTime);
     set_pvar(SPVAR_21,RF_hold); 
     set_pvar(SPVAR_22,RF_release);
     set_pvar(SPVAR_24,SlideDelay);
     set_pvar(SPVAR_26,HeadShotHoldTime);
     set_pvar(SPVAR_27,HeadShotStrength);
     set_pvar(SPVAR_29,polar_aasist_radius); 
     set_pvar(SPVAR_30,polar_aasist_steps);
     set_pvar(SPVAR_32,trackingSize);
     set_pvar(SPVAR_33,trackingSpeed);
     set_pvar(SPVAR_35,aimglitch1);
	 set_pvar(SPVAR_36,aimglitch2);
	 set_pvar(SPVAR_39,antidw_vertical);
	 set_pvar(SPVAR_40,antidw_horizontal);
	 set_pvar(SPVAR_42,SteadyAimResolution);
	 set_pvar(SPVAR_43,TrackerStrength);
	 set_pvar(SPVAR_44,TrackerSpeed);
	 set_pvar(SPVAR_46,RADIUS);
	set_pvar(SPVAR_47,ACTIVE_TRACKING);
	set_pvar(SPVAR_48,FractioN);
	set_pvar(SPVAR_53,ANGLE);
	set_pvar(SPVAR_49,AIM_SMOOTHING_FACTOR);
	set_pvar(SPVAR_51,SitBitchStartTime);
	set_pvar(SPVAR_52,SitBitchTime);
    combo_run(EXIT);                  
      
}// end of save   
                      
combo MESSAGE {       
    wait(20);         
    save_toggles ();  
    cls_oled(0);      
    print(horizontal_center_offset(sizeof(EXIT_TXT1), OLED_FONT_MEDIUM ), 2, OLED_FONT_MEDIUM, 1, EXIT_TXT1[0]); 
    print(horizontal_center_offset(sizeof(EXIT_TXT2), OLED_FONT_MEDIUM ), 23, OLED_FONT_MEDIUM, 1, EXIT_TXT2[0]);
    exit_wait = 2000;     
}                        
function blinck ( var){  
	if(var){               
		BlinckColor = Green;
	}else{                 
		BlinckColor = Red;    
	}                       
	combo_run(BLINK_NOTIFY); 
}                           
                            
combo BLINK_NOTIFY {        
	colourled(BlinckColor);   
	wait(300);                 
	colourled(ColorOFF);        
	wait(100);                  
	colourled(BlinckColor);      
	wait(300);                   
	colourled(ColorOFF);          
}                                
                                
                                
const uint8 FONT_STATS[][] = {  
    {  7, 10, 18 }, // Small    
    { 11, 18, 11 }, // Medium   
    { 16, 26,  7 }  // Large    
};                              
                                
function display_edit(  f_val) {
    print(2, 5, OLED_FONT_SMALL, OLED_WHITE, EditVarStr[adjust_variable_idx]); 
    number_to_string(f_val, find_digits(f_val));     
}       
        
function f_go_forward (f_variable) {
    f_variable       +=1;   
    if(f_variable  > Min_Max_Options[modName_idx][1] )f_variable  = Min_Max_Options[modName_idx][0]; // max option 
    blinck( f_variable );
    return f_variable;
}

function f_go_back (f_variable) {
    f_variable       -=1;   
    if(f_variable  < Min_Max_Options[modName_idx][0] )f_variable  = Min_Max_Options[modName_idx][1];
    blinck( f_variable );
    return f_variable;
}
// Variables for function number_to_string()  
int ssss;                            
int c_c_c,c_val;   
function number_to_string(f_val,f_digits) {                  
//=======================================================
//  number_to_string(value to convert, # of digits in value) 
//                                                           
//  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767) 
//                                                      
//      Convert digits to ASCII                         
//      Add ASCII character to print buffer            
//      Print string centered X & Y on OLED             
//                                                       
//======================================================
    ssss = 1;  c_val = 10000;                            
                                                      
    if(f_val < 0) //--neg numbers                     
    {                                                 
         putc_oled(ssss,45);    //--add leading "-"      
         ssss += 1;                                      
         f_val = abs(f_val);                          
    }                                                 
                                                      
    for(c_c_c = 5; c_c_c >= 1; c_c_c--)                           
    {                                                 
        if(f_digits >= c_c_c)                             
        {                                             
            putc_oled(ssss,ASCII_NUM[f_val / c_val]);    
            f_val = f_val % c_val;                    
            ssss +=  1;                                  
            if(c_c_c == 4)                               
            {                                         
                putc_oled(ssss,44);   //--add ","        
                ssss += 1;                               
            }                                        
        }                                             
        c_val /= 10;                                  
    }                                                
    puts_oled(center_x(ssss - 1,OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,ssss - 1,OLED_WHITE); // adjustable value centered in X 
}                                                     
int n_str_;                     
                             
function print_number(f_val,f_digits ,print_s_x , print_s_y , f_font) { 
                                                      
    n_str_ = 1;  c_val = 10000;                       
                                                      
    if(f_val < 0) //--neg numbers                     
    {                                                 
         putc_oled(n_str_,45);    //--add leading "-" 
         n_str_ += 1;                                 
         f_val = abs(f_val);                          
                                                      
    }                                                 
                                                      
    for(c_c_c = 5; c_c_c >= 1; c_c_c--)                           
    {                                                 
        if(f_digits >= c_c_c)                             
        {                                              
            putc_oled(n_str_,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;                    
            n_str_ +=  1;                             
                                                      
        }                                             
        c_val /= 10;                                  
    }                                                 
    puts_oled(print_s_x,print_s_y,f_font,n_str_ - 1,OLED_WHITE); // adjustable value centered in X
}                                       
                                                      
                                                      
int f_min, f_max;
function edit_val( f_val ) {  // antirecoil = edit_val( 0 , antirecoil, 99  , 99  )                                         
    f_min = ValRange[adjust_variable_idx][0];                          
    f_max = ValRange[adjust_variable_idx][1];                          
    print_number(f_min ,find_digits(f_min) ,4 , 22 , OLED_FONT_SMALL); 
    // on the right: max value                                         
    print_number(f_max ,find_digits(f_max) ,97 , 22 , OLED_FONT_SMALL);
                                          
    if(get_ival(BTN_AIM)){                  
		if(press_hold(PS4_RIGHT)){            
			f_val ++;                           
			if(f_val > f_max ) f_val = f_max;   
			display_EDIT = TRUE;
		}                                     
                                          
		if(press_hold(PS4_LEFT)){             
			f_val --;                           
			if(f_val < f_min ) f_val = f_min;   
			display_EDIT = TRUE;
		}                                     
		if(press_hold(PS4_UP)){               
			f_val +=10;                         
			if(f_val > f_max ) f_val = f_max;   
			display_EDIT = TRUE; 
		}                                     
                                          
		if(press_hold(PS4_DOWN)){             
			f_val -=10;                         
			if(f_val < f_min ) f_val = f_min;   
			display_EDIT = TRUE;
		}                                     
	}                                      
    return f_val;                        
}                                        
                                             
                                   
function press_hold(f_btn) {       
//  return TRUE - event_press()    
//- every 250ms when button is held 
	  return event_press(f_btn) || get_ival(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}               
                
function find_digits(f_num) {                         
//  find_digits(value)                                
//        return Number of Digits in Value Passed     
                                                      
    f_num = abs(f_num);                               
    if(f_num / 10000 > 0) return 5;                   
    if(f_num /  1000 > 0) return 4;                   
    if(f_num /   100 > 0) return 3;                   
    if(f_num /    10 > 0) return 2;                   
                          return 1;                  
}                                                     
///////////////////////////////////////////////
//  FUNCTIONS                                 
                                              
function center_x(f_chars,f_font) {           
//  center_x(number of chars,font size);     
//        return X for Centering String Horizontally 
                                                      
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2); 
}                                                      

const string ModOption_30_0 = "Disable"; 
const string ModOption_30_1 = "Circular"; 
const string ModOption_30_2 = "Tall Oval"; 
const string ModOption_30_3 = "Wide Oval"; 
const string ModOption_30_4 = "Spiral"; 
const string ModOption_30_5 = "Helix";
const string ModOption_50_0 = "Default"; 
const string ModOption_50_1 = "8 ms"; 
const string ModOption_50_2 = "6 ms"; 
const string ModOption_50_3 = "4 ms"; 
const string ModOption_50_4 = "2 ms"; 
const string ModOption_50_5 = "1 ms"; 
define ShotModOptions = 31;
const string ModOption_31_0 = "Disable"; 
const string ModOption_31_1 = "Fire Only"; 
const string ModOption_31_2 = "ADS & Fire"; 
const string ModOption_31_3 = "ADS Only"; 
const string ModOption_31_4 = "On Fire";
define FireModOptions =  9;
const string ModOption_9_0 = "Disable"; 
const string ModOption_9_1 = "Fire Only"; 
const string ModOption_9_2 = "ADS & Fire"; 
const string ModOption_9_3 = "On Fire";
function display_mod( f_string, mod_name, f_toggle, f_option) {   
        // Display MOD_NAME                                    
        print(f_string, 8, OLED_FONT_SMALL, OLED_WHITE, mod_name); 
        if(f_option == 1)                              
        {                                                     
        // Display Disable / Enable                                 
            if(f_toggle == 1)                                                             
                print(center_x(sizeof(ON)  - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE, ON[0]);// Enable 
            else                                                                                               
                print(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);// Disable 
        }            
        if(f_option == ShotModOptions)// 31    
        {                                                     
            if(f_toggle == 0)                                                             
                print(center_x(sizeof(ModOption_31_0)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_31_0[0]);// Disable
                                                                                                                           
            if(f_toggle == 1)                                                             
                print(center_x(sizeof(ModOption_31_1)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_31_1[0]);// Fire Only
                                                                                                                           
            if(f_toggle == 2)                                                             
                print(center_x(sizeof(ModOption_31_2)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_31_2[0]);// ADS & Fire
                                                                                                                           
            if(f_toggle == 3)                                                             
                print(center_x(sizeof(ModOption_31_3)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_31_3[0]);// ADS Only
                                                                                                                 
            if(f_toggle == 4)                                                             
                print(center_x(sizeof(ModOption_31_4)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_31_4[0]);// On Fire
		}
		
		if(f_option == FireModOptions)// 9 FireModOptions   
        {                                                     
            if(f_toggle == 0)                                                             
                print(center_x(sizeof(ModOption_31_0)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_9_0[0]);// Disable
                                                                                                                           
            if(f_toggle == 1)                                                             
                print(center_x(sizeof(ModOption_31_1)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_9_1[0]);// Fire Only
                                                                                                                           
            if(f_toggle == 2)                                                             
                print(center_x(sizeof(ModOption_31_2)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_9_2[0]);// ADS & Fire
                                                                                                                 
            if(f_toggle == 3)                                                             
                print(center_x(sizeof(ModOption_31_4)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_9_3[0]);// On Fire                                                                                                         
        } 

        if(f_option == 50)   
        {                                                     
            if(f_toggle == 0)                                                             
                print(center_x(sizeof(ModOption_50_0)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_50_0[0]);// Default
                                                                                                                           
            if(f_toggle == 1)                                                             
                print(center_x(sizeof(ModOption_50_1)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_50_1[0]);// 8 ms
                                                                                                                           
            if(f_toggle == 2)                                                             
                print(center_x(sizeof(ModOption_50_2)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_50_2[0]);// 6 ms
                                                                                                                           
            if(f_toggle == 3)                                                             
                print(center_x(sizeof(ModOption_50_3)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_50_3[0]);// 4 ms
                                                                                                                           
            if(f_toggle == 4)                                                             
                print(center_x(sizeof(ModOption_50_4)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_50_4[0]);// 2 ms
                                                                                                                           
            if(f_toggle == 5)                                                             
                print(center_x(sizeof(ModOption_50_5)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_50_5[0]);// 1 ms
                                                                                                                           
        }
        
        if(f_option == 30)   
        {                                                     
            if(f_toggle == 0)                                                             
                print(center_x(sizeof(ModOption_30_0)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_30_0[0]);// Disable
                                                                                                                           
            if(f_toggle == 1)                                                             
                print(center_x(sizeof(ModOption_30_1)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_30_1[0]);// Circular
                                                                                                                           
            if(f_toggle == 2)                                                             
                print(center_x(sizeof(ModOption_30_2)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_30_2[0]);// Tall Oval
                                                                                                                           
            if(f_toggle == 3)                                                             
                print(center_x(sizeof(ModOption_30_3)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_30_3[0]);// Wide Oval
                                                                                                                           
            if(f_toggle == 4)                                                             
                print(center_x(sizeof(ModOption_30_4)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_30_4[0]);// Spiral
                                                                                                                           
            if(f_toggle == 5)                                                             
                print(center_x(sizeof(ModOption_30_5)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_30_5[0]);// Helix
                                                                                                                           
        }
  
}//display mod end           

int aimAssistAngle,aimAssistX,aimAssistY,spinAngle,spinX,spinY,logo_radius;
 // Displays the initial greeting
function executeGreeting() {
	// Must be a minimum of 2
	logo_radius = 1;
	
	// Get coordinates
	aimAssistX = (logo_radius >> 1) * cos[aimAssistAngle];
	aimAssistY = logo_radius * sin[aimAssistAngle];
	
	// Calculate offset
  	spinX = ((aimAssistX * cos[spinAngle]) / 328) - ((aimAssistY * sin[spinAngle]) / 328);
	spinY = ((aimAssistX * sin[spinAngle]) / 328) + ((aimAssistY * cos[spinAngle]) / 328);
  	// Prepare to output
  	aimAssistX = spinX;
  	aimAssistY = spinY;
  	
  	// Step ahead 
	aimAssistAngle += 1;
	spinAngle += 10;
	
	if(aimAssistAngle >= 360) {
		aimAssistAngle %= 360;
	}
	
	if(spinAngle >= 360) {
		spinAngle %= 360;
	}
	
	pixel_oled(32 + (((aimAssistX / logo_radius) * 30) / 328), 32 + (((aimAssistY / logo_radius) * 30) / 328), OLED_WHITE);
}     
const uint8 MenuButtons [] = {  
  PS4_RIGHT , //0. Up
  PS4_LEFT , //1. Down
  PS4_UP , //2. go back
  PS4_DOWN , //3. go forward
  PS4_CROSS , //4. enter in Edit Menu
  PS4_CIRCLE , //5. exit  Menu
  PS4_OPTIONS , //5. enter in  Menu
  PS4_L2     //6. hold ADS
};//--- End Menu Buttons  

int menu_btn_indx;
int MenuTimeOut;
define menu_time_active = 30000;
function CheckIfBtnIsPressed (){  
    for(menu_btn_indx = 0; menu_btn_indx < 7; menu_btn_indx++){
         if(event_press(MenuButtons[menu_btn_indx]) ){
             MenuTimeOut = menu_time_active;
         }
         if(MenuTimeOut){              
            MenuTimeOut -=1;
            if(MenuTimeOut <= 0 ){    
                ModMenu = FALSE;      
                ModEdit = FALSE;      
                display_EDIT  = FALSE; 
                display_black = TRUE; 
            }
        }
    }
}
const int16 cos[] = { 
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328,
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6
}
// sin(x)
const int16 sin[] = { 
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328
} ˙πãæå¥çºåÕ˘»˛«ˆ¬